
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/joshsoftware/peerly-backend/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/joshsoftware/peerly-backend/internal/api/appreciation.go (89.7%)</option>
				
				<option value="file2">github.com/joshsoftware/peerly-backend/internal/api/coreValues.go (80.5%)</option>
				
				<option value="file3">github.com/joshsoftware/peerly-backend/internal/api/helper.go (85.7%)</option>
				
				<option value="file4">github.com/joshsoftware/peerly-backend/internal/api/ping.go (0.0%)</option>
				
				<option value="file5">github.com/joshsoftware/peerly-backend/internal/api/reward.go (76.2%)</option>
				
				<option value="file6">github.com/joshsoftware/peerly-backend/internal/api/router.go (0.0%)</option>
				
				<option value="file7">github.com/joshsoftware/peerly-backend/internal/api/user.go (47.4%)</option>
				
				<option value="file8">github.com/joshsoftware/peerly-backend/internal/api/validation/user.go (100.0%)</option>
				
				<option value="file9">github.com/joshsoftware/peerly-backend/internal/app/app.go (0.0%)</option>
				
				<option value="file10">github.com/joshsoftware/peerly-backend/internal/app/appreciation/helper.go (69.8%)</option>
				
				<option value="file11">github.com/joshsoftware/peerly-backend/internal/app/appreciation/mocks/Service.go (53.3%)</option>
				
				<option value="file12">github.com/joshsoftware/peerly-backend/internal/app/appreciation/service.go (47.4%)</option>
				
				<option value="file13">github.com/joshsoftware/peerly-backend/internal/app/coreValues/helper.go (32.0%)</option>
				
				<option value="file14">github.com/joshsoftware/peerly-backend/internal/app/coreValues/mocks/Service.go (82.6%)</option>
				
				<option value="file15">github.com/joshsoftware/peerly-backend/internal/app/coreValues/service.go (82.7%)</option>
				
				<option value="file16">github.com/joshsoftware/peerly-backend/internal/app/reward/mocks/Service.go (52.6%)</option>
				
				<option value="file17">github.com/joshsoftware/peerly-backend/internal/app/reward/service.go (84.6%)</option>
				
				<option value="file18">github.com/joshsoftware/peerly-backend/internal/app/users/mocks/Service.go (56.7%)</option>
				
				<option value="file19">github.com/joshsoftware/peerly-backend/internal/pkg/apperrors/errors.go (70.0%)</option>
				
				<option value="file20">github.com/joshsoftware/peerly-backend/internal/pkg/config/config.go (0.0%)</option>
				
				<option value="file21">github.com/joshsoftware/peerly-backend/internal/pkg/dto/appreciation.go (71.4%)</option>
				
				<option value="file22">github.com/joshsoftware/peerly-backend/internal/pkg/dto/response.go (76.0%)</option>
				
				<option value="file23">github.com/joshsoftware/peerly-backend/internal/pkg/logger/log.go (0.0%)</option>
				
				<option value="file24">github.com/joshsoftware/peerly-backend/internal/pkg/middleware/jwtMiddleware.go (0.0%)</option>
				
				<option value="file25">github.com/joshsoftware/peerly-backend/internal/repository/init.go (0.0%)</option>
				
				<option value="file26">github.com/joshsoftware/peerly-backend/internal/repository/mocks/AppreciationStorer.go (44.3%)</option>
				
				<option value="file27">github.com/joshsoftware/peerly-backend/internal/repository/mocks/CoreValueStorer.go (73.7%)</option>
				
				<option value="file28">github.com/joshsoftware/peerly-backend/internal/repository/mocks/RepositoryTransaction.go (0.0%)</option>
				
				<option value="file29">github.com/joshsoftware/peerly-backend/internal/repository/mocks/RewardStorer.go (53.8%)</option>
				
				<option value="file30">github.com/joshsoftware/peerly-backend/internal/repository/mocks/Transaction.go (0.0%)</option>
				
				<option value="file31">github.com/joshsoftware/peerly-backend/internal/repository/mocks/UserStorer.go (0.0%)</option>
				
				<option value="file32">github.com/joshsoftware/peerly-backend/internal/repository/postgresdb/appreciation.go (0.0%)</option>
				
				<option value="file33">github.com/joshsoftware/peerly-backend/internal/repository/postgresdb/base.go (0.0%)</option>
				
				<option value="file34">github.com/joshsoftware/peerly-backend/internal/repository/postgresdb/coreValues.go (0.0%)</option>
				
				<option value="file35">github.com/joshsoftware/peerly-backend/internal/repository/postgresdb/helper.go (0.0%)</option>
				
				<option value="file36">github.com/joshsoftware/peerly-backend/internal/repository/postgresdb/rewards.go (0.0%)</option>
				
				<option value="file37">github.com/joshsoftware/peerly-backend/internal/repository/postgresdb/user.go (0.0%)</option>
				
				<option value="file38">github.com/joshsoftware/peerly-backend/internal/repository/seed.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

// @APITitle Main
// @APIDescription Main API for Microservices in Go!

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "os"
        "strconv"

        "github.com/go-co-op/gocron/v2"
        "github.com/joshsoftware/peerly-backend/internal/api"
        "github.com/joshsoftware/peerly-backend/internal/app"
        "github.com/joshsoftware/peerly-backend/internal/app/cronjob"
        "github.com/joshsoftware/peerly-backend/internal/pkg/config"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        "github.com/rs/cors"
        logger "github.com/sirupsen/logrus"
        "github.com/urfave/cli"
        "github.com/urfave/negroni"
)

func main() <span class="cov0" title="0">{
        logger.SetFormatter(&amp;logger.TextFormatter{
                FullTimestamp:   true,
                TimestampFormat: "02-01-2006 15:04:05",
        })

        config.Load()

        cliApp := cli.NewApp()
        cliApp.Name = config.AppName()
        cliApp.Version = "1.0.0"
        cliApp.Commands = []cli.Command{
                {
                        Name:  "start",
                        Usage: "start server",
                        Action: func(c *cli.Context) error </span><span class="cov0" title="0">{
                                return startApp()
                        }</span>,
                },
                {
                        Name:  "create_migration",
                        Usage: "create migration file",
                        Action: func(c *cli.Context) error <span class="cov0" title="0">{
                                return repository.CreateMigrationFile(c.Args().Get(0))
                        }</span>,
                },
                {
                        Name:  "migrate",
                        Usage: "run db migrations",
                        Action: func(c *cli.Context) error <span class="cov0" title="0">{
                                return repository.RunMigrations()
                        }</span>,
                },
                {
                        Name:      "rollback",
                        Usage:     "rollback migrations [step (int)]",
                        ArgsUsage: "[step (int)]",
                        Action: func(c *cli.Context) error <span class="cov0" title="0">{
                                if c.NArg() == 0 </span><span class="cov0" title="0">{
                                        return errors.New("migration step is required")
                                }</span>
                                <span class="cov0" title="0">return repository.RollbackMigrations(c.Args().Get(0))</span>
                        },
                },
                {
                        Name:  "seed",
                        Usage: "seed data in database",
                        Action: func(c *cli.Context) error <span class="cov0" title="0">{
                                return repository.SeedData()
                        }</span>,
                },
        }

        <span class="cov0" title="0">if err := cliApp.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func startApp() (err error) <span class="cov0" title="0">{

        // Context for main function
        ctx := context.Background()
        logger.Info("Starting Peerly Application...")
        defer logger.Info("Shutting Down Peerly Application...")
        //initialize database
        dbInstance, err := repository.InitializeDatabase()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("Database init failed")
                return
        }</span>

        //cors
        <span class="cov0" title="0">c := cors.New(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowCredentials: true,
                AllowedMethods:   []string{http.MethodGet, http.MethodPost, http.MethodPut, http.MethodDelete, http.MethodOptions},
                AllowedHeaders:   []string{"*"},
        })

        //initialize service dependencies
        services := app.NewService(dbInstance)

        // Initializing Cron Job
        scheduler, err := gocron.NewScheduler()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "scheduler creation failed with error: %s", err.Error())
                return
        }</span>

        <span class="cov0" title="0">cronjob.InitializeJobs(services.AppreciationService,scheduler)
        defer scheduler.Shutdown()
        //initialize router
        router := api.NewRouter(services)

        // init web server
        server := negroni.Classic()
        server.Use(c)
        server.UseHandler(router)

        port := config.AppPort()
        addr := fmt.Sprintf(":%s", strconv.Itoa(port))
        server.Run(addr)
        return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/joshsoftware/peerly-backend/internal/app/appreciation"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        logger "github.com/sirupsen/logrus"
)

func createAppreciationHandler(appreciationSvc appreciation.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                var appreciation dto.Appreciation
                err := json.NewDecoder(req.Body).Decode(&amp;appreciation)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithField("err", err.Error()).Error("Error while decoding request data")
                        err = apperrors.JSONParsingErrorReq
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">err = appreciation.CreateAppreciation()

                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">resp, err := appreciationSvc.CreateAppreciation(req.Context(), appreciation)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusCreated, "Appreciation created successfully", resp)</span>
        })
}

func getAppreciationByIdHandler(appreciationSvc appreciation.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{

                vars := mux.Vars(req)
                apprId, err := strconv.Atoi(vars["id"])
                if err != nil </span><span class="cov0" title="0">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">fmt.Println("appr: ", apprId)
                resp, err := appreciationSvc.GetAppreciationById(req.Context(), apprId)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Appreciation data got successfully", resp)</span>
        })
}

// getAppreciationsHandler handles HTTP requests for appreciations
func getAppreciationsHandler(appreciationSvc appreciation.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{

                var filter dto.AppreciationFilter

                // Extract query parameters or body fields
                filter.Name = req.URL.Query().Get("name")
                filter.SortOrder = req.URL.Query().Get("sort_order")
                
                // Get pagination parameters
                page,limit, err := getPaginationParams(req)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, apperrors.BadRequest)
                        return
                }</span>
                
                <span class="cov8" title="1">filter.Limit = limit
                filter.Page = page
                // Call your appreciationService to fetch appreciations based on filter
                appreciations, err := appreciationSvc.GetAppreciation(req.Context(), filter)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Appreciations data got successfully ", appreciations)</span>
        })
}

func validateAppreciationHandler(appreciationSvc appreciation.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                vars := mux.Vars(req)
                apprId, err := strconv.Atoi(vars["id"])
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, apperrors.BadRequest)
                        return
                }</span>

                <span class="cov8" title="1">res, err := appreciationSvc.ValidateAppreciation(req.Context(), false, apprId)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">if !res </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, apperrors.InternalServer)
                        return
                }</span>
                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Appreciation invalidate successfully", nil)</span>
        })
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "encoding/json"
        "net/http"

        "github.com/gorilla/mux"
        corevalues "github.com/joshsoftware/peerly-backend/internal/app/coreValues"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        logger "github.com/sirupsen/logrus"
)

func listCoreValuesHandler(coreValueSvc corevalues.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{

                coreValues, err := coreValueSvc.ListCoreValues(req.Context())
                if err != nil </span><span class="cov8" title="1">{

                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Core values listed", coreValues)</span>
        })
}

func getCoreValueHandler(coreValueSvc corevalues.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                vars := mux.Vars(req)

                coreValue, err := coreValueSvc.GetCoreValue(req.Context(), vars["id"])
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Core value listed", coreValue)</span>
        })
}

func createCoreValueHandler(coreValueSvc corevalues.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                const userId int64 = 1
                var coreValue dto.CreateCoreValueReq
                err := json.NewDecoder(req.Body).Decode(&amp;coreValue)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithField("err", err.Error()).Error("Error while decoding request data")
                        err = apperrors.JSONParsingErrorReq
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">resp, err := coreValueSvc.CreateCoreValue(req.Context(), userId, coreValue)
                if err != nil </span><span class="cov8" title="1">{

                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Core value created", resp)</span>
        })
}

func updateCoreValueHandler(coreValueSvc corevalues.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                vars := mux.Vars(req)

                var updateReq dto.UpdateQueryRequest
                err := json.NewDecoder(req.Body).Decode(&amp;updateReq)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithField("err", err.Error()).Error("Error while decoding request data")
                        err = apperrors.JSONParsingErrorReq
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">resp, err := coreValueSvc.UpdateCoreValue(req.Context(), vars["id"], updateReq)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Core value created", resp)</span>
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "strconv"
)

func getPaginationParams(req *http.Request) (int64, int64, error) <span class="cov8" title="1">{
        pageStr := req.URL.Query().Get("page")
        limitStr := req.URL.Query().Get("limit")

        fmt.Println("pagestr: ", pageStr, " limitstr: ", limitStr)
        var page int64
        var limit int64
        var err error

        if pageStr == "" </span><span class="cov8" title="1">{
                page = 1
                limit = 10
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Hello page limit")
                page, err = strconv.ParseInt(pageStr, 10, 64)
                if err != nil || page &lt; 1 </span><span class="cov8" title="1">{
                        return 0, 0, errors.New("invalid page parameter")
                }</span>

                <span class="cov8" title="1">if limitStr == "" </span><span class="cov0" title="0">{
                        fmt.Println("empty limit")
                        limit = 10
                }</span> else<span class="cov8" title="1"> {
                        limit, err = strconv.ParseInt(limitStr, 10, 64)
                        if err != nil || limit &lt; 1 </span><span class="cov0" title="0">{
                                return 0, 0, errors.New("invalid limit parameter")
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Println("page: ", page, " limit: ", limit)
        return page, limit, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "net/http"

        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
)

func pingHandler(rw http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        dto.SuccessRepsonse(rw, http.StatusOK, "Success", "pong")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/joshsoftware/peerly-backend/internal/app/reward"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        logger "github.com/sirupsen/logrus"
)


func giveRewardHandler(rewardSvc reward.Service) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                vars := mux.Vars(req)
                apprId, err := strconv.Atoi(vars["id"])
                if err != nil </span><span class="cov0" title="0">{
                        dto.ErrorRepsonse(rw, apperrors.BadRequest)
                        return
                }</span>

                <span class="cov8" title="1">var reward dto.Reward
                err = json.NewDecoder(req.Body).Decode(&amp;reward)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error decoding request data:", err.Error())
                        dto.ErrorRepsonse(rw, apperrors.JSONParsingErrorReq)
                        return
                }</span>
                

                <span class="cov8" title="1">if reward.Point &lt;1 || reward.Point &gt;5 </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw,apperrors.InvalidRewardPoint)
                        return 
                }</span>
                <span class="cov8" title="1">reward.AppreciationId = int64(apprId)
                resp, err := rewardSvc.GiveReward(req.Context(),reward)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusCreated, "Reward given successfully", resp)</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "fmt"
        "net/http"

        "github.com/gorilla/mux"
        "github.com/joshsoftware/peerly-backend/internal/app"
        "github.com/joshsoftware/peerly-backend/internal/pkg/config"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        "github.com/joshsoftware/peerly-backend/internal/pkg/middleware"
)

const (
        versionHeader = "Accept-Version"
        authHeader    = "X-Auth-Token"
)

// NewRouter initializes and returns a new router with the specified dependencies.
func NewRouter(deps app.Dependencies) *mux.Router <span class="cov0" title="0">{

        router := mux.NewRouter()

        router.HandleFunc("/ping", pingHandler).Methods(http.MethodGet)
        // Version 1 API management
        v1 := fmt.Sprintf("application/vnd.%s.v1", config.AppName())

        //corevalues
        router.Handle("/core_values/{id:[0-9]+}", middleware.JwtAuthMiddleware(getCoreValueHandler(deps.CoreValueService), []string{constants.UserRole})).Methods(http.MethodGet).Headers(versionHeader, v1)

        router.Handle("/core_values", middleware.JwtAuthMiddleware(listCoreValuesHandler(deps.CoreValueService), []string{constants.UserRole})).Methods(http.MethodGet).Headers(versionHeader, v1)

        router.Handle("/core_values", middleware.JwtAuthMiddleware(createCoreValueHandler(deps.CoreValueService), []string{constants.UserRole})).Methods(http.MethodPost).Headers(versionHeader, v1)

        router.Handle("/core_values/{id:[0-9]+}", middleware.JwtAuthMiddleware(updateCoreValueHandler(deps.CoreValueService), []string{constants.UserRole})).Methods(http.MethodPut).Headers(versionHeader, v1)

        //login
        router.Handle("/user/register", registerUser(deps.UserService)).Methods(http.MethodPost)

        router.Handle("/user/login", loginUser(deps.UserService)).Methods(http.MethodGet).Headers(versionHeader, v1)

        router.Handle("/users", getIntranetUserListHandler(deps.UserService)).Methods(http.MethodGet)

        router.Handle("/users/all", middleware.JwtAuthMiddleware(getUserHandler(deps.UserService), []string{constants.UserRole})).Methods(http.MethodGet).Headers(versionHeader, v1)

        //appreciations

        router.Handle("/appreciation/{id:[0-9]+}", middleware.JwtAuthMiddleware(getAppreciationByIdHandler(deps.AppreciationService), []string{constants.UserRole})).Methods(http.MethodGet).Headers(versionHeader, v1)

        router.Handle("/appreciations", middleware.JwtAuthMiddleware(getAppreciationsHandler(deps.AppreciationService), []string{constants.UserRole})).Methods(http.MethodGet).Headers(versionHeader, v1)

        router.Handle("/appreciation/{id:[0-9]+}", middleware.JwtAuthMiddleware(validateAppreciationHandler(deps.AppreciationService), []string{constants.UserRole})).Methods(http.MethodDelete).Headers(versionHeader, v1)

        router.Handle("/appreciation", middleware.JwtAuthMiddleware(createAppreciationHandler(deps.AppreciationService), []string{constants.UserRole})).Methods(http.MethodPost).Headers(versionHeader, v1)

        // reward appreciation

        router.Handle("/reward/{id:[0-9]+}", middleware.JwtAuthMiddleware(giveRewardHandler(deps.RewardService), []string{constants.UserRole})).Methods(http.MethodPost).Headers(versionHeader, v1)

        return router
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "github.com/joshsoftware/peerly-backend/internal/api/validation"
        user "github.com/joshsoftware/peerly-backend/internal/app/users"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        logger "github.com/sirupsen/logrus"
)

func loginUser(userSvc user.Service) http.HandlerFunc <span class="cov8" title="1">{
        return func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                authToken := req.Header.Get(constants.IntranetAuth)
                if authToken == "" </span><span class="cov8" title="1">{
                        err := apperrors.InvalidAuthToken
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">validateResp, err := userSvc.ValidatePeerly(req.Context(), authToken)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">reqData := dto.GetIntranetUserDataReq{
                        Token:  validateResp.Data.JwtToken,
                        UserId: validateResp.Data.UserId,
                }

                user, err := userSvc.GetIntranetUserData(req.Context(), reqData)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">err = validation.GetIntranetUserDataValidation(user)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">resp, err := userSvc.LoginUser(req.Context(), user)
                if err != nil </span><span class="cov8" title="1">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Login successful", resp)</span>

        }
}

func getIntranetUserListHandler(userSvc user.Service) http.HandlerFunc <span class="cov0" title="0">{
        return func(rw http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{

                authToken := req.Header.Get(constants.IntranetAuth)
                if authToken == "" </span><span class="cov0" title="0">{
                        err := apperrors.InvalidAuthToken
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov0" title="0">page := req.URL.Query().Get("page")
                if page == "" </span><span class="cov0" title="0">{
                        err := apperrors.PageParamNotFound
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov0" title="0">pageInt, _ := strconv.Atoi(page)

                validateResp, err := userSvc.ValidatePeerly(req.Context(), authToken)
                if err != nil </span><span class="cov0" title="0">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov0" title="0">reqData := dto.GetUserListReq{
                        AuthToken: validateResp.Data.JwtToken,
                        Page:      pageInt,
                }

                usersData, err := userSvc.GetUserListIntranet(req.Context(), reqData)
                if err != nil </span><span class="cov0" title="0">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov0" title="0">dto.SuccessRepsonse(rw, http.StatusOK, "Intranet users listed", usersData)</span>
        }
}

func registerUser(userSvc user.Service) http.HandlerFunc <span class="cov0" title="0">{
        return func(rw http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                var user dto.IntranetUserData
                err := json.NewDecoder(req.Body).Decode(&amp;user)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithField("err", err.Error()).Error("Error while decoding request data")
                        err = apperrors.JSONParsingErrorReq
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, err := userSvc.RegisterUser(req.Context(), user)
                if err != nil </span><span class="cov0" title="0">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov0" title="0">dto.SuccessRepsonse(rw, http.StatusOK, "User registered successfully", resp)</span>
        }
}

func getUserHandler(userSvc user.Service) http.HandlerFunc <span class="cov8" title="1">{
        return func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                page := req.URL.Query().Get("page")
                if page == "" </span><span class="cov0" title="0">{
                        err := apperrors.PageParamNotFound
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">pageInt, _ := strconv.Atoi(page)
                perPage := req.URL.Query().Get("per_page")
                var perPageInt int
                if perPage == "" </span><span class="cov0" title="0">{
                        perPageInt = constants.PerPage
                }</span> else<span class="cov8" title="1"> {
                        perPageInt, _ = strconv.Atoi(perPage)
                }</span>
                <span class="cov8" title="1">names := strings.Split(req.URL.Query().Get("name"), " ")
                userListReq := dto.UserListReq{
                        Name:    names,
                        Page:    pageInt,
                        PerPage: perPageInt,
                }
                resp, err := userSvc.GetUserList(req.Context(), userListReq)
                if err != nil </span><span class="cov0" title="0">{
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>
                <span class="cov8" title="1">dto.SuccessRepsonse(rw, http.StatusOK, "Intranet users listed", resp)</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package validation

import (
        "fmt"

        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
)

func GetIntranetUserDataValidation(user dto.IntranetUserData) (err error) <span class="cov8" title="1">{

        if user.PublicProfile.FirstName == "" || user.PublicProfile.LastName == "" || user.EmpolyeeDetail.Designation.Name == "" || user.Email == "" || user.EmpolyeeDetail.Grade == "" </span><span class="cov8" title="1">{
                fmt.Println("Invalid user data")
                fmt.Println("First Name: ", user.PublicProfile.FirstName)
                fmt.Println("Last Name: ", user.PublicProfile.LastName)
                fmt.Println("Designation: ", user.EmpolyeeDetail.Designation.Name)
                fmt.Println("Email: ", user.Email)
                fmt.Println("Grade: ", user.EmpolyeeDetail.Grade)
                fmt.Println("Profile image: ", user.PublicProfile.ProfileImgUrl)

                err = apperrors.InvalidIntranetData
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package app

import (
        "github.com/jmoiron/sqlx"
        "github.com/joshsoftware/peerly-backend/internal/app/appreciation"
        corevalues "github.com/joshsoftware/peerly-backend/internal/app/coreValues"
        reward "github.com/joshsoftware/peerly-backend/internal/app/reward"
        user "github.com/joshsoftware/peerly-backend/internal/app/users"
        repository "github.com/joshsoftware/peerly-backend/internal/repository/postgresdb"
)

// Dependencies holds the dependencies required by the application.
type Dependencies struct {
        CoreValueService    corevalues.Service
        AppreciationService appreciation.Service
        UserService         user.Service
        RewardService       reward.Service
}

// NewService initializes and returns a Dependencies instance with the given database connection.
func NewService(db *sqlx.DB) Dependencies <span class="cov0" title="0">{
        // Initialize repository dependencies using the provided database connection.

        coreValueRepo := repository.NewCoreValueRepo(db)
        userRepo := repository.NewUserRepo(db)
        appreciationRepo := repository.NewAppreciationRepo(db)
        rewardRepo := repository.NewRewardRepo(db)

        coreValueService := corevalues.NewService(coreValueRepo)
        userService := user.NewService(userRepo)
        appreciationService := appreciation.NewService(appreciationRepo, coreValueRepo)
        rewardService := reward.NewService(rewardRepo,appreciationRepo)

        return Dependencies{
                CoreValueService:    coreValueService,
                AppreciationService: appreciationService,
                UserService:         userService,
                RewardService:       rewardService,
        }

}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package appreciation

import (
        "fmt"
        "time"

        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
)

// Function to map AppreciationDB to AppreciationDTO
func MapAppreciationDBToDTO(dbAppreciation repository.Appreciation) dto.Appreciation <span class="cov8" title="1">{

        fmt.Println("db: ",dbAppreciation)
        // fmt.Println("dto: ",)
        return dto.Appreciation{
                ID:           dbAppreciation.ID,
                CoreValueID:  dbAppreciation.CoreValueID,
                Description:  dbAppreciation.Description,
                TotalRewards: dbAppreciation.TotalRewards,
                Quarter:      dbAppreciation.Quarter,
                Sender:       dbAppreciation.Sender,
                Receiver:     dbAppreciation.Receiver,
                CreatedAt:    dbAppreciation.CreatedAt,
                UpdatedAt:    dbAppreciation.UpdatedAt,
        }
}</span>

func mapRepoGetAppreciationInfoToDTOGetAppreciationInfo(info repository.AppreciationInfo) dto.ResponseAppreciation <span class="cov8" title="1">{

        receiverImageURL := ""
        if info.ReceiverImageURL.Valid </span><span class="cov8" title="1">{
                receiverImageURL = info.ReceiverImageURL.String
        }</span>

        <span class="cov8" title="1">senderImageURL := ""
        if info.SenderImageURL.Valid </span><span class="cov8" title="1">{
                senderImageURL = info.SenderImageURL.String
        }</span>

        <span class="cov8" title="1">var dtoApprResp dto.ResponseAppreciation

        dtoApprResp.ID = info.ID
        dtoApprResp.CoreValueName = info.CoreValueName
        dtoApprResp.Description = info.Description
        dtoApprResp.TotalRewards = info.TotalRewards
        dtoApprResp.Quarter = info.Quarter
        dtoApprResp.SenderFirstName = info.SenderFirstName
        dtoApprResp.SenderLastName = info.SenderLastName
        dtoApprResp.SenderImageURL = senderImageURL
        dtoApprResp.SenderDesignation = info.SenderDesignation
        dtoApprResp.ReceiverFirstName = info.ReceiverFirstName
        dtoApprResp.ReceiverLastName = info.ReceiverLastName
        dtoApprResp.ReceiverImageURL = receiverImageURL
        dtoApprResp.ReceiverDesignation = info.ReceiverDesignation
        dtoApprResp.CreatedAt = info.CreatedAt
        dtoApprResp.UpdatedAt = info.UpdatedAt
        return dtoApprResp</span>
}

func GetQuarter() int <span class="cov8" title="1">{
        month := int(time.Now().Month())
        if month &gt;= 1 &amp;&amp; month &lt;= 3 </span><span class="cov0" title="0">{
                return 1
        }</span> else<span class="cov8" title="1"> if month &gt;= 4 &amp;&amp; month &lt;= 6 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov8" title="1"> if month &gt;= 7 &amp;&amp; month &lt;= 9 </span><span class="cov8" title="1">{
                return 3
        }</span> else<span class="cov0" title="0"> if month &gt;= 10 &amp;&amp; month &lt;= 12 </span><span class="cov0" title="0">{
                return 4
        }</span>
        <span class="cov0" title="0">return -1</span>
}

func DtoPagination (pagination repository.Pagination)dto.Pagination <span class="cov0" title="0">{
        var pagenationResp dto.Pagination
        pagenationResp.CurrentPage = pagination.CurrentPage
        pagenationResp.Next = pagination.Next
        pagenationResp.Previous = pagination.Previous
        pagenationResp.RecordPerPage = pagination.RecordPerPage
        pagenationResp.TotalPage =pagination.TotalPage
        pagenationResp.TotalRecords = pagination.TotalRecords
        return pagenationResp
}</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        dto "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        mock "github.com/stretchr/testify/mock"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
        mock.Mock
}

// CreateAppreciation provides a mock function with given fields: ctx, apprecication
func (_m *Service) CreateAppreciation(ctx context.Context, apprecication dto.Appreciation) (dto.Appreciation, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, apprecication)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateAppreciation")</span>
        }

        <span class="cov8" title="1">var r0 dto.Appreciation
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, dto.Appreciation) (dto.Appreciation, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, apprecication)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, dto.Appreciation) dto.Appreciation); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, apprecication)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.Appreciation)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, dto.Appreciation) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, apprecication)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetAppreciation provides a mock function with given fields: ctx, filter
func (_m *Service) GetAppreciation(ctx context.Context, filter dto.AppreciationFilter) (dto.GetAppreciationResponse, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, filter)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAppreciation")</span>
        }

        <span class="cov8" title="1">var r0 dto.GetAppreciationResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, dto.AppreciationFilter) (dto.GetAppreciationResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, filter)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, dto.AppreciationFilter) dto.GetAppreciationResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, filter)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.GetAppreciationResponse)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, dto.AppreciationFilter) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, filter)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetAppreciationById provides a mock function with given fields: ctx, appreciationId
func (_m *Service) GetAppreciationById(ctx context.Context, appreciationId int) (dto.ResponseAppreciation, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, appreciationId)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAppreciationById")</span>
        }

        <span class="cov8" title="1">var r0 dto.ResponseAppreciation
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (dto.ResponseAppreciation, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, appreciationId)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) dto.ResponseAppreciation); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, appreciationId)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.ResponseAppreciation)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, appreciationId)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UpdateAppreciation provides a mock function with given fields: ctx
func (_m *Service) UpdateAppreciation(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateAppreciation")</span>
        }

        <span class="cov0" title="0">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ValidateAppreciation provides a mock function with given fields: ctx, isValid, apprId
func (_m *Service) ValidateAppreciation(ctx context.Context, isValid bool, apprId int) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, isValid, apprId)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ValidateAppreciation")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bool, int) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, isValid, apprId)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, bool, int) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, isValid, apprId)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, bool, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, isValid, apprId)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
        mock.TestingT
        Cleanup(func())
}) *Service <span class="cov0" title="0">{
        mock := &amp;Service{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package appreciation

import (
        "context"

        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        logger "github.com/sirupsen/logrus"
)

type service struct {
        appreciationRepo repository.AppreciationStorer
        corevaluesRespo  repository.CoreValueStorer
}

type Service interface {
        CreateAppreciation(ctx context.Context, apprecication dto.Appreciation) (dto.Appreciation, error)
        GetAppreciationById(ctx context.Context, appreciationId int) (dto.ResponseAppreciation, error)
        GetAppreciation(ctx context.Context, filter dto.AppreciationFilter) (dto.GetAppreciationResponse, error)
        ValidateAppreciation(ctx context.Context, isValid bool, apprId int) (bool, error)
        UpdateAppreciation(ctx context.Context) (bool, error)
}

func NewService(appreciationRepo repository.AppreciationStorer, coreValuesRepo repository.CoreValueStorer) Service <span class="cov8" title="1">{
        return &amp;service{
                appreciationRepo: appreciationRepo,
                corevaluesRespo:  coreValuesRepo,
        }
}</span>

func (apprSvc *service) CreateAppreciation(ctx context.Context, apprecication dto.Appreciation) (dto.Appreciation, error) <span class="cov8" title="1">{

        //add quarter
        apprecication.Quarter = GetQuarter()

        //add sender
        data := ctx.Value(constants.UserId)
        sender, ok := data.(int64)
        if !ok </span><span class="cov0" title="0">{
                logger.Error("err in parsing userid from token")
                return dto.Appreciation{},apperrors.InternalServer
        }</span>
        <span class="cov8" title="1">usrChk,err := apprSvc.appreciationRepo.IsUserPresent(ctx,nil,sender)
        if err != nil </span><span class="cov0" title="0">{
                return dto.Appreciation{},err
        }</span>

        <span class="cov8" title="1">if !usrChk  </span><span class="cov0" title="0">{
                return dto.Appreciation{},apperrors.UserNotFound
        }</span>

        <span class="cov8" title="1">apprecication.Sender = sender

        //initializing database transaction
        tx, err := apprSvc.appreciationRepo.BeginTx(ctx)
        
        if err != nil </span><span class="cov8" title="1">{
                return dto.Appreciation{}, err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
        rvr := recover()
        defer func() </span><span class="cov8" title="1">{
            if rvr != nil </span><span class="cov0" title="0">{
                logger.Info(ctx, "Transaction aborted because of panic: %v, Propagating panic further", rvr)
                panic(rvr)</span>
            }
        }()

        <span class="cov8" title="1">txErr := apprSvc.appreciationRepo.HandleTransaction(ctx, tx, err == nil &amp;&amp; rvr == nil)
        if txErr != nil </span><span class="cov8" title="1">{
            err = txErr
            logger.Info(ctx, "error in creating transaction, err: %s", txErr.Error())
            return
        }</span>
    }()


        //check is corevalue present in database
        <span class="cov8" title="1">_, err = apprSvc.corevaluesRespo.GetCoreValue(ctx, int64(apprecication.CoreValueID))
        if err != nil </span><span class="cov8" title="1">{
                return dto.Appreciation{}, err
        }</span>

        //check is receiver present in database
        <span class="cov8" title="1">chk, err := apprSvc.appreciationRepo.IsUserPresent(ctx, tx, apprecication.Receiver)
        if err != nil </span><span class="cov8" title="1">{
                return dto.Appreciation{}, err
        }</span>
        <span class="cov8" title="1">if !chk </span><span class="cov0" title="0">{
                return dto.Appreciation{}, apperrors.UserNotFound
        }</span>

        // check self appreciation
        <span class="cov8" title="1">if apprecication.Receiver == sender </span><span class="cov0" title="0">{
                return dto.Appreciation{},apperrors.SelfAppreciationError
        }</span>

        <span class="cov8" title="1">appr, err := apprSvc.appreciationRepo.CreateAppreciation(ctx, tx, apprecication)
        if err != nil </span><span class="cov0" title="0">{
                return dto.Appreciation{}, err
        }</span>

        <span class="cov8" title="1">return MapAppreciationDBToDTO(appr), nil</span>
}

func (apprSvc *service) GetAppreciationById(ctx context.Context, appreciationId int) (dto.ResponseAppreciation, error) <span class="cov8" title="1">{

        
        resAppr, err := apprSvc.appreciationRepo.GetAppreciationById(ctx, nil, appreciationId)
        if err != nil </span><span class="cov8" title="1">{
                return dto.ResponseAppreciation{}, err
        }</span>

        <span class="cov8" title="1">return mapRepoGetAppreciationInfoToDTOGetAppreciationInfo(resAppr), nil</span>
}

func (apprSvc *service) GetAppreciation(ctx context.Context, filter dto.AppreciationFilter) (dto.GetAppreciationResponse, error) <span class="cov0" title="0">{
        infos,pagination, err := apprSvc.appreciationRepo.GetAppreciation(ctx, nil, filter)
        if err != nil </span><span class="cov0" title="0">{
                return dto.GetAppreciationResponse{}, err
        }</span>

        <span class="cov0" title="0">responses := make([]dto.ResponseAppreciation,0)
        for _, info := range infos </span><span class="cov0" title="0">{
                response := mapRepoGetAppreciationInfoToDTOGetAppreciationInfo(info)
                responses = append(responses, response)
        }</span>
        <span class="cov0" title="0">paginationResp := DtoPagination(pagination)
        return dto.GetAppreciationResponse{Appreciations:responses,Pagination: paginationResp}, nil</span>
}

func (apprSvc *service) ValidateAppreciation(ctx context.Context, isValid bool, apprId int) (bool, error) <span class="cov8" title="1">{
        return apprSvc.appreciationRepo.ValidateAppreciation(ctx, nil, isValid, apprId)
}</span>

func (apprSvc *service) UpdateAppreciation(ctx context.Context) (bool, error) <span class="cov0" title="0">{

        //initializing database transaction
        tx, err := apprSvc.appreciationRepo.BeginTx(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                rvr := recover()
                defer func() </span><span class="cov0" title="0">{
                        if rvr != nil </span><span class="cov0" title="0">{
                                logger.Info(ctx, "Transaction aborted because of panic: %v, Propagating panic further", rvr)
                                panic(rvr)</span>
                        }
                }()

                <span class="cov0" title="0">txErr := apprSvc.appreciationRepo.HandleTransaction(ctx, tx, err == nil &amp;&amp; rvr == nil)
                if txErr != nil </span><span class="cov0" title="0">{
                        err = txErr
                        logger.Info(ctx, "error in creating transaction, err: %s", txErr.Error())
                        return
                }</span>
        }()

        <span class="cov0" title="0">_, err = apprSvc.appreciationRepo.UpdateAppreciationTotalRewardsOfYesterday(ctx, tx)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err: ", err.Error())
                return false, err
        }</span>

        <span class="cov0" title="0">_,err = apprSvc.appreciationRepo.UpdateUserBadgesBasedOnTotalRewards(ctx,tx)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err: ", err.Error())
                return false, err
        }</span>

        <span class="cov0" title="0">return true,nil</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package corevalues

import (
        "context"
        "fmt"
        "strconv"

        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        logger "github.com/sirupsen/logrus"
)

func validateParentCoreValue(ctx context.Context, storer repository.CoreValueStorer, coreValueID int64) (ok bool) <span class="cov0" title="0">{
        coreValue, err := storer.GetCoreValue(ctx, coreValueID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("Parent core value id not present")
                return
        }</span>

        <span class="cov0" title="0">if coreValue.ParentCoreValueID != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid parent core value id")
                return
        }</span>

        <span class="cov0" title="0">return true</span>
}

func Validate(ctx context.Context, coreValue dto.CreateCoreValueReq, storer repository.CoreValueStorer) (err error) <span class="cov8" title="1">{

        if coreValue.Name == "" </span><span class="cov0" title="0">{
                err = apperrors.TextFieldBlank
        }</span>
        <span class="cov8" title="1">if coreValue.Description == "" </span><span class="cov0" title="0">{
                err = apperrors.DescFieldBlank
        }</span>
        <span class="cov8" title="1">if coreValue.ParentCoreValueID != nil </span><span class="cov0" title="0">{
                if !validateParentCoreValue(ctx, storer, *coreValue.ParentCoreValueID) </span><span class="cov0" title="0">{
                        err = apperrors.InvalidParentValue
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

func VarsStringToInt(inp string, label string) (result int64, err error) <span class="cov8" title="1">{

        if len(inp) &lt;= 0 </span><span class="cov0" title="0">{
                err = apperrors.InvalidOrgId
                return
        }</span>
        <span class="cov8" title="1">result, err = strconv.ParseInt(inp, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error(fmt.Scanf("Error while parsing %s from url", label))
                err = apperrors.InternalServerError
                return

        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import context "context"

import dto "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
import mock "github.com/stretchr/testify/mock"

// Service is an autogenerated mock type for the Service type
type Service struct {
        mock.Mock
}

// CreateCoreValue provides a mock function with given fields: ctx, userId, coreValue
func (_m *Service) CreateCoreValue(ctx context.Context, userId int64, coreValue dto.CreateCoreValueReq) (dto.CreateCoreValueResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, userId, coreValue)

        var r0 dto.CreateCoreValueResp
        if rf, ok := ret.Get(0).(func(context.Context, int64, dto.CreateCoreValueReq) dto.CreateCoreValueResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userId, coreValue)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.CreateCoreValueResp)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, int64, dto.CreateCoreValueReq) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userId, coreValue)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}


// GetCoreValue provides a mock function with given fields: ctx, coreValueID
func (_m *Service) GetCoreValue(ctx context.Context, coreValueID string) (dto.GetCoreValueResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, coreValueID)

        var r0 dto.GetCoreValueResp
        if rf, ok := ret.Get(0).(func(context.Context, string) dto.GetCoreValueResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, coreValueID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.GetCoreValueResp)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, coreValueID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// ListCoreValues provides a mock function with given fields: ctx
func (_m *Service) ListCoreValues(ctx context.Context) ([]dto.ListCoreValuesResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        var r0 []dto.ListCoreValuesResp
        if rf, ok := ret.Get(0).(func(context.Context) []dto.ListCoreValuesResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]dto.ListCoreValuesResp)
                }</span>
        }

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UpdateCoreValue provides a mock function with given fields: ctx, coreValueID, coreValue
func (_m *Service) UpdateCoreValue(ctx context.Context, coreValueID string, coreValue dto.UpdateQueryRequest) (dto.UpdateCoreValuesResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, coreValueID, coreValue)

        var r0 dto.UpdateCoreValuesResp
        if rf, ok := ret.Get(0).(func(context.Context, string, dto.UpdateQueryRequest) dto.UpdateCoreValuesResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, coreValueID, coreValue)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.UpdateCoreValuesResp)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, string, dto.UpdateQueryRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, coreValueID, coreValue)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

func NewService(t interface {
        mock.TestingT
        Cleanup(func())
}) *Service <span class="cov8" title="1">{
        mock := &amp;Service{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package corevalues

import (
        "context"

        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        logger "github.com/sirupsen/logrus"
)

type service struct {
        coreValuesRepo repository.CoreValueStorer
}

type Service interface {
        ListCoreValues(ctx context.Context) (resp []dto.ListCoreValuesResp, err error)
        GetCoreValue(ctx context.Context, coreValueID string) (coreValue dto.GetCoreValueResp, err error)
        CreateCoreValue(ctx context.Context, userId int64, coreValue dto.CreateCoreValueReq) (resp dto.CreateCoreValueResp, err error)
        UpdateCoreValue(ctx context.Context, coreValueID string, coreValue dto.UpdateQueryRequest) (resp dto.UpdateCoreValuesResp, err error)
}

func NewService(coreValuesRepo repository.CoreValueStorer) Service <span class="cov8" title="1">{
        return &amp;service{
                coreValuesRepo: coreValuesRepo,
        }
}</span>

func (cs *service) ListCoreValues(ctx context.Context) (resp []dto.ListCoreValuesResp, err error) <span class="cov8" title="1">{

        resp, err = cs.coreValuesRepo.ListCoreValues(ctx)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithField("err", err.Error()).Error("Error while fetching data")
                err = apperrors.InternalServerError
        }</span>

        <span class="cov8" title="1">return</span>

}

func (cs *service) GetCoreValue(ctx context.Context, coreValueID string) (coreValue dto.GetCoreValueResp, err error) <span class="cov8" title="1">{

        coreValId, err := VarsStringToInt(coreValueID, "coreValueId")
        if err != err </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">coreValue, err = cs.coreValuesRepo.GetCoreValue(ctx, coreValId)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithField("err", err.Error()).Error("Error while fetching data")
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (cs *service) CreateCoreValue(ctx context.Context, userId int64, coreValue dto.CreateCoreValueReq) (resp dto.CreateCoreValueResp, err error) <span class="cov8" title="1">{

        isUnique, err := cs.coreValuesRepo.CheckUniqueCoreVal(ctx, coreValue.Name)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !isUnique </span><span class="cov8" title="1">{
                err = apperrors.UniqueCoreValue
                return
        }</span>

        <span class="cov8" title="1">err = Validate(ctx, coreValue, cs.coreValuesRepo)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">resp, err = cs.coreValuesRepo.CreateCoreValue(ctx, userId, coreValue)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithField("err", err.Error()).Error("Error while creating core value")
                err = apperrors.InternalServerError
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (cs *service) UpdateCoreValue(ctx context.Context, coreValueID string, reqData dto.UpdateQueryRequest) (resp dto.UpdateCoreValuesResp, err error) <span class="cov8" title="1">{

        coreValId, err := VarsStringToInt(coreValueID, "coreValueId")
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        //validate corevalue
        //get data
        <span class="cov8" title="1">coreValue, err := cs.coreValuesRepo.GetCoreValue(ctx, coreValId)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithField("err", err.Error()).Error("Error while fetching data")
                return
        }</span>

        //set empty fields
        <span class="cov8" title="1">if reqData.Name == "" </span><span class="cov0" title="0">{
                reqData.Name = coreValue.Name
        }</span>
        <span class="cov8" title="1">if reqData.Description == "" </span><span class="cov0" title="0">{
                reqData.Description = coreValue.Description
        }</span>

        <span class="cov8" title="1">isUnique, err := cs.coreValuesRepo.CheckUniqueCoreVal(ctx, reqData.Name)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !isUnique &amp;&amp; reqData.Name != coreValue.Name </span><span class="cov0" title="0">{
                err = apperrors.UniqueCoreValue
                return
        }</span>

        <span class="cov8" title="1">resp, err = cs.coreValuesRepo.UpdateCoreValue(ctx, coreValId, reqData)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithField("err", err.Error()).Error("Error while updating core value")
                err = apperrors.InternalServerError

                return
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        dto "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        mock "github.com/stretchr/testify/mock"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
        mock.Mock
}

// GiveReward provides a mock function with given fields: ctx, rewardReq
func (_m *Service) GiveReward(ctx context.Context, rewardReq dto.Reward) (dto.Reward, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, rewardReq)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GiveReward")</span>
        }

        <span class="cov8" title="1">var r0 dto.Reward
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, dto.Reward) (dto.Reward, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, rewardReq)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, dto.Reward) dto.Reward); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, rewardReq)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.Reward)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, dto.Reward) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, rewardReq)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
        mock.TestingT
        Cleanup(func())
}) *Service <span class="cov0" title="0">{
        mock := &amp;Service{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package reward

import (
        "context"

        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        logger "github.com/sirupsen/logrus"
)

type service struct {
        rewardRepo       repository.RewardStorer
        appreciationRepo repository.AppreciationStorer
}

type Service interface {
        GiveReward(ctx context.Context, rewardReq dto.Reward) (dto.Reward, error)
}

func NewService(rewardRepo repository.RewardStorer, appreciationRepo repository.AppreciationStorer) Service <span class="cov0" title="0">{
        return &amp;service{
                rewardRepo:       rewardRepo,
                appreciationRepo: appreciationRepo,
        }
}</span>

func (rwrdSvc *service) GiveReward(ctx context.Context, rewardReq dto.Reward) (dto.Reward, error) <span class="cov8" title="1">{

        //add sender
        data := ctx.Value(constants.UserId)
        sender, ok := data.(int64)
        if !ok </span><span class="cov8" title="1">{
                logger.Error("err in parsing userid from token")
                return dto.Reward{}, apperrors.InternalServer
        }</span>
        <span class="cov8" title="1">rewardReq.SenderId = sender

        appr, err := rwrdSvc.appreciationRepo.GetAppreciationById(ctx, nil, int(rewardReq.AppreciationId))
        if err != nil </span><span class="cov0" title="0">{
                return dto.Reward{}, err
        }</span>

        <span class="cov8" title="1">if appr.SenderId == sender </span><span class="cov8" title="1">{
                return dto.Reward{},apperrors.SelfAppreciationRewardError
        }</span>

        <span class="cov8" title="1">if appr.ReceiverId == sender</span><span class="cov8" title="1">{
                return dto.Reward{},apperrors.SelfRewardError
        }</span>

        <span class="cov8" title="1">userChk, err := rwrdSvc.rewardRepo.UserHasRewardQuota(ctx, nil, rewardReq.SenderId,rewardReq.Point)
        if err != nil </span><span class="cov0" title="0">{
                return dto.Reward{}, err
        }</span>

        <span class="cov8" title="1">if !userChk </span><span class="cov8" title="1">{
                return dto.Reward{}, apperrors.RewardQuotaIsNotSufficient
        }</span>

        <span class="cov8" title="1">rwrdChk, err := rwrdSvc.rewardRepo.IsUserRewardForAppreciationPresent(ctx, nil, rewardReq.AppreciationId, rewardReq.SenderId)
        if err != nil </span><span class="cov0" title="0">{
                return dto.Reward{}, err
        }</span>

        <span class="cov8" title="1">if rwrdChk </span><span class="cov8" title="1">{
                return dto.Reward{}, apperrors.RewardAlreadyPresent
        }</span>

        //initializing database transaction
        <span class="cov8" title="1">tx, err := rwrdSvc.rewardRepo.BeginTx(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return dto.Reward{}, err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                rvr := recover()
                defer func() </span><span class="cov8" title="1">{
                        if rvr != nil </span><span class="cov0" title="0">{
                                logger.Info(ctx, "Transaction aborted because of panic: %v, Propagating panic further", rvr)
                                panic(rvr)</span>
                        }
                }()

                <span class="cov8" title="1">txErr := rwrdSvc.appreciationRepo.HandleTransaction(ctx, tx, err == nil &amp;&amp; rvr == nil)
                if txErr != nil </span><span class="cov8" title="1">{
                        err = txErr
                        logger.Info(ctx, "error in creating transaction, err: %s", txErr.Error())
                        return
                }</span>
        }()
        <span class="cov8" title="1">repoRewardRes, err := rwrdSvc.rewardRepo.GiveReward(ctx, tx, rewardReq)
        if err != nil </span><span class="cov0" title="0">{
                return dto.Reward{}, err
        }</span>

        //deduce user rewardquota

        <span class="cov8" title="1">deduceChk, err := rwrdSvc.rewardRepo.DeduceRewardQuotaOfUser(ctx, tx, rewardReq.SenderId,int(rewardReq.Point))
        if err != nil </span><span class="cov8" title="1">{
                return dto.Reward{}, err
        }</span>

        <span class="cov8" title="1">if !deduceChk </span><span class="cov0" title="0">{
                return dto.Reward{}, apperrors.InternalServer
        }</span>

        <span class="cov8" title="1">var reward dto.Reward
        reward.Id = repoRewardRes.Id
        reward.AppreciationId = repoRewardRes.AppreciationId
        reward.SenderId = repoRewardRes.SenderId
        reward.Point = repoRewardRes.Point
        return reward, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import context "context"
import dto "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
import mock "github.com/stretchr/testify/mock"

// Service is an autogenerated mock type for the Service type
type Service struct {
        mock.Mock
}

// GetIntranetUserData provides a mock function with given fields: ctx, req
func (_m *Service) GetIntranetUserData(ctx context.Context, req dto.GetIntranetUserDataReq) (dto.IntranetUserData, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, req)

        var r0 dto.IntranetUserData
        if rf, ok := ret.Get(0).(func(context.Context, dto.GetIntranetUserDataReq) dto.IntranetUserData); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, req)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.IntranetUserData)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, dto.GetIntranetUserDataReq) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, req)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetUserList provides a mock function with given fields: ctx, reqData
func (_m *Service) GetUserList(ctx context.Context, reqData dto.UserListReq) ([]dto.GetUserListResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, reqData)

        var r0 []dto.GetUserListResp
        if rf, ok := ret.Get(0).(func(context.Context, dto.UserListReq) []dto.GetUserListResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, reqData)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]dto.GetUserListResp)
                }</span>
        }

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, dto.UserListReq) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, reqData)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetUserListIntranet provides a mock function with given fields: ctx, reqData
func (_m *Service) GetUserListIntranet(ctx context.Context, reqData dto.GetUserListReq) ([]dto.IntranetUserData, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, reqData)

        var r0 []dto.IntranetUserData
        if rf, ok := ret.Get(0).(func(context.Context, dto.GetUserListReq) []dto.IntranetUserData); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, reqData)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]dto.IntranetUserData)
                }</span>
        }

        <span class="cov0" title="0">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, dto.GetUserListReq) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, reqData)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// LoginUser provides a mock function with given fields: ctx, u
func (_m *Service) LoginUser(ctx context.Context, u dto.IntranetUserData) (dto.LoginUserResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, u)

        var r0 dto.LoginUserResp
        if rf, ok := ret.Get(0).(func(context.Context, dto.IntranetUserData) dto.LoginUserResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, u)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.LoginUserResp)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, dto.IntranetUserData) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, u)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// RegisterUser provides a mock function with given fields: ctx, u
func (_m *Service) RegisterUser(ctx context.Context, u dto.IntranetUserData) (dto.GetUserResp, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, u)

        var r0 dto.GetUserResp
        if rf, ok := ret.Get(0).(func(context.Context, dto.IntranetUserData) dto.GetUserResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, u)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(dto.GetUserResp)
        }</span>

        <span class="cov0" title="0">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, dto.IntranetUserData) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, u)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ValidatePeerly provides a mock function with given fields: ctx, authToken
func (_m *Service) ValidatePeerly(ctx context.Context, authToken string) (dto.ValidateResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, authToken)

        var r0 dto.ValidateResp
        if rf, ok := ret.Get(0).(func(context.Context, string) dto.ValidateResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, authToken)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.ValidateResp)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, authToken)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

func NewService(t interface {
        mock.TestingT
        Cleanup(func())
}) *Service <span class="cov8" title="1">{
        mock := &amp;Service{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package apperrors

import (
        "fmt"
        "net/http"
)

// CustomError represents a custom error type as a string.
type CustomError string

// Error implements the error interface for CustomError.
// It converts the CustomError to a string and returns it.
func (e CustomError) Error() string <span class="cov8" title="1">{
        return string(e)
}</span>

// Custome errors with errormessage
const (
        InvalidId                  = CustomError("Invalid id")
        InternalServerError        = CustomError("Internal server error")
        JSONParsingErrorReq        = CustomError("error in parsing request in json")
        JSONParsingErrorResp       = CustomError("error in parsing response in json")
        OutOfRange                 = CustomError("request value is out of range")
        OrganizationNotFound       = CustomError("organization of given id not found")
        InvalidContactEmail        = CustomError("Contact email is already present")
        InvalidDomainName          = CustomError("Domain name is already present")
        InvalidCoreValueData       = CustomError("Invalid corevalue data")
        TextFieldBlank             = CustomError("Text field cannot be blank")
        DescFieldBlank             = CustomError("Description cannot be blank")
        InvalidParentValue         = CustomError("Invalid parent core value")
        InvalidOrgId               = CustomError("Invalid organisation")
        UniqueCoreValue            = CustomError("Choose a unique coreValue name")
        InvalidAuthToken           = CustomError("Invalid Auth token")
        IntranetValidationFailed   = CustomError("Intranet Validation Failed")
        UserNotFound               = CustomError("User not found")
        InvalidIntranetData        = CustomError("Invalid data recieved from intranet")
        GradeNotFound              = CustomError("Grade not found")
        AppreciationNotFound       = CustomError("appreciation not found")
        RoleUnathorized            = CustomError("Role unauthorized")
        PageParamNotFound          = CustomError("Page parameter not found")
        RepeatedUser               = CustomError("Repeated user")
        BadRequest                 = CustomError("Bad request")
        InternalServer             = CustomError("Internal Server")
        FailedToCreateDriver       = CustomError("failure to create driver obj")
        MigrationFailure           = CustomError("migrate failure")
        SelfAppreciationError      = CustomError("user cannot give appreciation to ourself")
        UserAlreadyPresent         = CustomError("user already present")
        RewardAlreadyPresent       = CustomError("reward already present")
        RewardQuotaIsNotSufficient = CustomError("reward quota is not sufficient")
        InvalidRewardPoint         = CustomError("invalid reward point")
        SelfRewardError                                = CustomError("user cannot give reward to ourself")
        SelfAppreciationRewardError = CustomError("user cannot give reward to his posted appreciaiton ")
)

// ErrKeyNotSet - Returns error object specific to the key value passed in
func ErrKeyNotSet(key string) (err error) <span class="cov0" title="0">{
        return fmt.Errorf("key not set: %s", key)
}</span>

// GetHTTPStatusCode returns status code according to customerror and default returns InternalServer error
func GetHTTPStatusCode(err error) int <span class="cov8" title="1">{
        switch err </span>{
        case InternalServerError, JSONParsingErrorResp, InvalidIntranetData:<span class="cov8" title="1">
                return http.StatusInternalServerError</span>
        case OrganizationNotFound, InvalidCoreValueData, InvalidParentValue, InvalidOrgId, GradeNotFound, AppreciationNotFound, PageParamNotFound:<span class="cov8" title="1">
                return http.StatusNotFound</span>
        case BadRequest, InvalidId, JSONParsingErrorReq, TextFieldBlank, DescFieldBlank, UniqueCoreValue, IntranetValidationFailed, RepeatedUser, SelfAppreciationError,InvalidRewardPoint:<span class="cov8" title="1">
                return http.StatusBadRequest</span>
        case InvalidContactEmail, InvalidDomainName, UserAlreadyPresent, RewardAlreadyPresent:<span class="cov0" title="0">
                return http.StatusConflict</span>
        case InvalidAuthToken, RoleUnathorized:<span class="cov8" title="1">
                return http.StatusUnauthorized</span>
        case RewardQuotaIsNotSufficient:<span class="cov0" title="0">
                return http.StatusUnprocessableEntity</span>

        default:<span class="cov8" title="1">
                return http.StatusInternalServerError</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package config

import (
        "fmt"
        "strconv"

        "github.com/joho/godotenv"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        "github.com/spf13/viper"
)

var (
        appName string
        appPort int
)

// Load - loads all the environment variables and/or params in application.yml
func Load() <span class="cov0" title="0">{

        // Load environment variables from .env file
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error loading .env file: %v", err))</span>
        }
        <span class="cov0" title="0">viper.ReadInConfig()
        viper.AutomaticEnv()

        viper.SetDefault(constants.AppName, "app")
        viper.SetDefault(constants.AppPort, "8002")

        // Check for the presence of JWT_KEY and JWT_EXPIRY_DURATION_HOURS
        JWTKey()
        JWTExpiryDurationHours()</span>
}

// AppName - returns the app name
func AppName() string <span class="cov0" title="0">{
        if appName == "" </span><span class="cov0" title="0">{
                appName = ReadEnvString(constants.AppName)
        }</span>
        <span class="cov0" title="0">return appName</span>
}

// AppPort - returns application http port
func AppPort() int <span class="cov0" title="0">{
        if appPort == 0 </span><span class="cov0" title="0">{
                appPort = ReadEnvInt(constants.AppPort)
        }</span>
        <span class="cov0" title="0">return appPort</span>
}

// JWTKey - returns the JSON Web Token key
func JWTKey() []byte <span class="cov0" title="0">{
        return []byte(ReadEnvString(constants.JWTSecret))
}</span>

// JWTExpiryDurationHours - returns duration for jwt expiry in int
func JWTExpiryDurationHours() int <span class="cov0" title="0">{
        return int(ReadEnvInt(constants.JWTExpiryDurationHours))
}</span>

// ReadEnvInt - reads an environment variable as an integer
func ReadEnvInt(key string) int <span class="cov0" title="0">{
        checkIfSet(key)
        v, err := strconv.Atoi(viper.GetString(key))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("key %s is not a valid integer", key))</span>
        }
        <span class="cov0" title="0">return v</span>
}

// ReadEnvString - reads an environment variable as a string
func ReadEnvString(key string) string <span class="cov0" title="0">{
        checkIfSet(key)
        return viper.GetString(key)
}</span>

// ReadEnvBool - reads environment variable as a boolean
func ReadEnvBool(key string) bool <span class="cov0" title="0">{
        checkIfSet(key)
        return viper.GetBool(key)
}</span>

func checkIfSet(key string) <span class="cov0" title="0">{
        if !viper.IsSet(key) </span><span class="cov0" title="0">{
                panic(apperrors.ErrKeyNotSet(key))</span>
        }
}

func IntranetClientCode() string <span class="cov0" title="0">{
        return ReadEnvString("INTRANET_CLIENT_CODE")
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package dto

import "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"

type Appreciation struct {
        ID           int64  `json:"id"`
        CoreValueID  int    `json:"core_value_id" `
        Description  string `json:"description"`
        TotalRewards int    `json:"total_rewards,omitempty"`
        Quarter      int    `json:"quarter"`
        Sender       int64  `json:"sender"`
        Receiver     int64  `json:"receiver"`
        CreatedAt    int64  `json:"created_at"`
        UpdatedAt    int64  `json:"updated_at"`
}

type AppreciationFilter struct {
        Name      string `json:"sender_name"`
        SortOrder string `json:"sort_order"`
        Page      int64  `json:"page"`
        Limit     int64  `json:"limit"`
}

type ResponseAppreciation struct {
        ID                  int    `json:"id"`
        CoreValueName       string `json:"core_value_name"`
        Description         string `json:"description"`
        TotalRewards        int    `json:"total_rewards"`
        Quarter             string `json:"quarter"`
        SenderFirstName     string `json:"sender_first_name"`
        SenderLastName      string `json:"sender_last_name"`
        SenderImageURL      string `json:"sender_image_url"`
        SenderDesignation   string `json:"sender_designation"`
        ReceiverFirstName   string `json:"receiver_first_name"`
        ReceiverLastName    string `json:"receiver_last_name"`
        ReceiverImageURL    string `json:"receiver_image_url"`
        ReceiverDesignation string `json:"receiver_designation"`
        CreatedAt           int64  `json:"created_at"`
        UpdatedAt           int64  `json:"updated_at"`
}

// Pagination Object
type Pagination struct {
    Next          *int64 `json:"next"`
    Previous      *int64 `json:"previous"`
    RecordPerPage int64  `json:"record_per_page"`
    CurrentPage   int64  `json:"current_page"`
    TotalPage     int64  `json:"total_page"`
    TotalRecords  int64  `json:"total_records"`
}

type GetAppreciationResponse struct {
        Appreciations []ResponseAppreciation `json:"appreciations"`
        Pagination
}

func (appr *Appreciation) CreateAppreciation() (err error) <span class="cov8" title="1">{

        if appr.CoreValueID &lt;= 0 </span><span class="cov8" title="1">{
                return apperrors.InvalidId
        }</span>

        <span class="cov8" title="1">if appr.Description == "" </span><span class="cov0" title="0">{
                return apperrors.DescFieldBlank
        }</span>

        <span class="cov8" title="1">if appr.Receiver &lt;= 0 </span><span class="cov0" title="0">{
                return apperrors.InvalidId
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package dto

import (
        "encoding/json"
        "net/http"

        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        logger "github.com/sirupsen/logrus"
)

// Response is common response struct used in SuccessRepsonse and ErrorRepsonse
type Response struct {
        Success bool        `json:"success"`
        Message string      `json:"message"`
        Status  int         `json:"status_code"`
        Data    interface{} `json:"data"`
}

// SuccessRepsonse return success response
func SuccessRepsonse(rw http.ResponseWriter, status int, message string, data interface{}) <span class="cov8" title="1">{

        var resp Response
        resp.Success = true
        resp.Status = status
        resp.Message = message
        resp.Data = data

        respBytes, err := json.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("Error while marshaling core values data")
                rw.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">rw.Header().Add("Content-Type", "application/json")
        rw.WriteHeader(status)
        rw.Write(respBytes)</span>
}

// ErrorRepsonse return error response
func ErrorRepsonse(rw http.ResponseWriter, err error) <span class="cov8" title="1">{

        var resp Response
        resp.Success = false
        resp.Status = apperrors.GetHTTPStatusCode(err)
        resp.Message = err.Error()

        respBytes, err := json.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("Error while marshaling core values data")
                rw.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">rw.Header().Add("Content-Type", "application/json")
        rw.WriteHeader(resp.Status)
        rw.Write(respBytes)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package log

import (
        l "github.com/sirupsen/logrus"
)

// Error - prints out an error
func Error(appError error, msg string, triggeringError error) <span class="cov0" title="0">{
        l.WithFields(l.Fields{"appError": appError, "message": msg}).Error(triggeringError)
}</span>

// Warn - for warnings
func Warn(appError error, msg string, triggeringError error) <span class="cov0" title="0">{
        l.WithFields(l.Fields{"appError": appError, "message": msg}).Warn(triggeringError)
}</span>

// Fatal - will print out the error info and exit the program
func Fatal(appError error, msg string, triggeringError error) <span class="cov0" title="0">{
        l.WithFields(l.Fields{"appError": appError, "message": msg}).Fatal(triggeringError)
}</span>

// Info - prints out basic information
func Info(msg string) <span class="cov0" title="0">{
        l.WithFields(l.Fields{"info": msg}).Info(msg)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "context"
        "net/http"
        "slices"

        "github.com/dgrijalva/jwt-go"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/config"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        logger "github.com/sirupsen/logrus"
)

func JwtAuthMiddleware(next http.Handler, roles []string) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                // next.ServeHTTP(rw, req)
                jwtKey := config.JWTKey()
                authToken := req.Header.Get(constants.AuthorizationHeader)
                if authToken == "" </span><span class="cov0" title="0">{
                        logger.Error("Empty auth token")
                        err := apperrors.InvalidAuthToken
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov0" title="0">claims := &amp;dto.Claims{}

                tkn, err := jwt.ParseWithClaims(authToken, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return jwtKey, nil
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.WithField("err", err.Error()).Error("Error in parse with claims function")
                        err = apperrors.InvalidAuthToken
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov0" title="0">if !tkn.Valid </span><span class="cov0" title="0">{
                        logger.Error("Invalid token")
                        err = apperrors.InvalidAuthToken
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                <span class="cov0" title="0">var Id int64 = claims.Id
                var Role string = claims.Role

                if !slices.Contains(roles, Role) </span><span class="cov0" title="0">{
                        err := apperrors.RoleUnathorized
                        dto.ErrorRepsonse(rw, err)
                        return
                }</span>

                // set id and role to context
                <span class="cov0" title="0">ctx := context.WithValue(req.Context(), constants.UserId, Id)
                ctx = context.WithValue(ctx, constants.Role, Role)
                req = req.WithContext(ctx)

                next.ServeHTTP(rw, req)</span>

        })
}

func RecoverMiddleware(next http.Handler, roles []string) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        rvr := recover()
                        if rvr != nil </span><span class="cov0" title="0">{
                                logger.Error("err ", rvr)
                                dto.ErrorRepsonse(rw, apperrors.InternalServer)
                        }</span>
                }()

                <span class="cov0" title="0">next.ServeHTTP(rw, req)</span>
        })
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "database/sql"
        "errors"
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/jmoiron/sqlx"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/config"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        logger "github.com/sirupsen/logrus"

        // Import PostgreSQL database driver
        _ "github.com/lib/pq"

        // For database migrations
        "github.com/golang-migrate/migrate"
        "github.com/golang-migrate/migrate/database/postgres"
        // golang-migrate reads migrations from sources and applies them in correct order to a database.
        _ "github.com/golang-migrate/migrate/source/file"
)

const (
        dbDriver = "postgres"
)

// InitializeDatabase initialize database and return database instance
func InitializeDatabase() (db *sqlx.DB, err error) <span class="cov0" title="0">{
        uri := config.ReadEnvString(constants.DBURI)

        conn, err := sqlx.Connect(dbDriver, uri)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("Cannot initialize database")
                return
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

// RunMigrations - runs all database migrations (see ../migrtions/*.up.sql)
func RunMigrations() (err error) <span class="cov0" title="0">{
        uri := config.ReadEnvString(constants.DBURI)

        db, _ := sql.Open(dbDriver, uri)

        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("failure to create driver obj")
                return apperrors.FailedToCreateDriver
        }</span>

        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(getMigrationPath(), dbDriver, driver)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("migrate failure")
                return apperrors.MigrationFailure
        }</span>

        <span class="cov0" title="0">err = m.Up()
        if err == migrate.ErrNoChange || err == nil </span><span class="cov0" title="0">{
                err = nil
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

// CreateMigrationFile - Creates a boilerplate *.sql files for a database migration
func CreateMigrationFile(filename string) (err error) <span class="cov0" title="0">{
        if len(filename) == 0 </span><span class="cov0" title="0">{
                err = errors.New("filename is not provided")
                return
        }</span>
        
        <span class="cov0" title="0">timeStamp := time.Now().Unix()
        upMigrationFilePath := fmt.Sprintf("%s/%d_%s.up.sql", config.ReadEnvString(constants.MigrationFolderPath), timeStamp, filename)
        downMigrationFilePath := fmt.Sprintf("%s/%d_%s.down.sql", config.ReadEnvString(constants.MigrationFolderPath), timeStamp, filename)
        err = createFile(upMigrationFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = createFile(downMigrationFilePath)
        if err != nil </span><span class="cov0" title="0">{
                os.Remove(upMigrationFilePath)
                return
        }</span>

        <span class="cov0" title="0">logger.WithFields(logger.Fields{
                "up":   upMigrationFilePath,
                "down": downMigrationFilePath,
        }).Info("Created migration files")

        return</span>
}

// RollbackMigrations - Used to run the "down" database migrations in ../migrations/*.down.sql
func RollbackMigrations(s string) (err error) <span class="cov0" title="0">{
        uri := config.ReadEnvString(constants.DBURI)

        steps, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m, err := migrate.New(getMigrationPath(), uri)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = m.Steps(-1 * steps)
        if err == migrate.ErrNoChange || err == nil </span><span class="cov0" title="0">{
                err = nil
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func createFile(filename string) (err error) <span class="cov0" title="0">{
        f, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = f.Close()
        return</span>
}

func getMigrationPath() string <span class="cov0" title="0">{
        return fmt.Sprintf("file://%s", config.ReadEnvString(constants.MigrationFolderPath))
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        dto "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        mock "github.com/stretchr/testify/mock"

        repository "github.com/joshsoftware/peerly-backend/internal/repository"

        sqlx "github.com/jmoiron/sqlx"
)

// AppreciationStorer is an autogenerated mock type for the AppreciationStorer type
type AppreciationStorer struct {
        mock.Mock
}

// BeginTx provides a mock function with given fields: ctx
func (_m *AppreciationStorer) BeginTx(ctx context.Context) (repository.Transaction, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BeginTx")</span>
        }

        <span class="cov8" title="1">var r0 repository.Transaction
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (repository.Transaction, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context) repository.Transaction); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(repository.Transaction)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// CreateAppreciation provides a mock function with given fields: ctx, tx, appreciation
func (_m *AppreciationStorer) CreateAppreciation(ctx context.Context, tx repository.Transaction, appreciation dto.Appreciation) (repository.Appreciation, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, appreciation)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateAppreciation")</span>
        }

        <span class="cov8" title="1">var r0 repository.Appreciation
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, dto.Appreciation) (repository.Appreciation, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, appreciation)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, dto.Appreciation) repository.Appreciation); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, appreciation)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(repository.Appreciation)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, dto.Appreciation) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, appreciation)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetAppreciation provides a mock function with given fields: ctx, tx, filter
func (_m *AppreciationStorer) GetAppreciation(ctx context.Context, tx repository.Transaction, filter dto.AppreciationFilter) ([]repository.AppreciationInfo, repository.Pagination, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, tx, filter)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAppreciation")</span>
        }

        <span class="cov0" title="0">var r0 []repository.AppreciationInfo
        var r1 repository.Pagination
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, dto.AppreciationFilter) ([]repository.AppreciationInfo, repository.Pagination, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, filter)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, dto.AppreciationFilter) []repository.AppreciationInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, filter)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]repository.AppreciationInfo)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, dto.AppreciationFilter) repository.Pagination); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, filter)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Get(1).(repository.Pagination)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(2).(func(context.Context, repository.Transaction, dto.AppreciationFilter) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, tx, filter)
        }</span> else<span class="cov0" title="0"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov0" title="0">return r0, r1, r2</span>
}

// GetAppreciationById provides a mock function with given fields: ctx, tx, appreciationId
func (_m *AppreciationStorer) GetAppreciationById(ctx context.Context, tx repository.Transaction, appreciationId int) (repository.AppreciationInfo, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, appreciationId)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAppreciationById")</span>
        }

        <span class="cov8" title="1">var r0 repository.AppreciationInfo
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int) (repository.AppreciationInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, appreciationId)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int) repository.AppreciationInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, appreciationId)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(repository.AppreciationInfo)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, appreciationId)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// HandleTransaction provides a mock function with given fields: ctx, tx, isSuccess
func (_m *AppreciationStorer) HandleTransaction(ctx context.Context, tx repository.Transaction, isSuccess bool) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, isSuccess)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for HandleTransaction")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, bool) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, isSuccess)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// InitiateQueryExecutor provides a mock function with given fields: tx
func (_m *AppreciationStorer) InitiateQueryExecutor(tx repository.Transaction) sqlx.Ext <span class="cov0" title="0">{
        ret := _m.Called(tx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InitiateQueryExecutor")</span>
        }

        <span class="cov0" title="0">var r0 sqlx.Ext
        if rf, ok := ret.Get(0).(func(repository.Transaction) sqlx.Ext); ok </span><span class="cov0" title="0">{
                r0 = rf(tx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sqlx.Ext)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// IsUserPresent provides a mock function with given fields: ctx, tx, userID
func (_m *AppreciationStorer) IsUserPresent(ctx context.Context, tx repository.Transaction, userID int64) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for IsUserPresent")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int64) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, userID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int64) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, userID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, int64) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, userID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UpdateAppreciationTotalRewardsOfYesterday provides a mock function with given fields: ctx, tx
func (_m *AppreciationStorer) UpdateAppreciationTotalRewardsOfYesterday(ctx context.Context, tx repository.Transaction) (bool, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, tx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateAppreciationTotalRewardsOfYesterday")</span>
        }

        <span class="cov0" title="0">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UpdateUserBadgesBasedOnTotalRewards provides a mock function with given fields: ctx, tx
func (_m *AppreciationStorer) UpdateUserBadgesBasedOnTotalRewards(ctx context.Context, tx repository.Transaction) (bool, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, tx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateUserBadgesBasedOnTotalRewards")</span>
        }

        <span class="cov0" title="0">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ValidateAppreciation provides a mock function with given fields: ctx, tx, isValid, apprId
func (_m *AppreciationStorer) ValidateAppreciation(ctx context.Context, tx repository.Transaction, isValid bool, apprId int) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, isValid, apprId)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ValidateAppreciation")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, bool, int) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, isValid, apprId)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, bool, int) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, isValid, apprId)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, bool, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, isValid, apprId)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewAppreciationStorer creates a new instance of AppreciationStorer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAppreciationStorer(t interface {
        mock.TestingT
        Cleanup(func())
}) *AppreciationStorer <span class="cov8" title="1">{
        mock := &amp;AppreciationStorer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        dto "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        mock "github.com/stretchr/testify/mock"
)

// CoreValueStorer is an autogenerated mock type for the CoreValueStorer type
type CoreValueStorer struct {
        mock.Mock
}

// CheckUniqueCoreVal provides a mock function with given fields: ctx, text
func (_m *CoreValueStorer) CheckUniqueCoreVal(ctx context.Context, text string) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, text)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CheckUniqueCoreVal")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, text)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, text)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, text)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// CreateCoreValue provides a mock function with given fields: ctx, userId, coreValue
func (_m *CoreValueStorer) CreateCoreValue(ctx context.Context, userId int64, coreValue dto.CreateCoreValueReq) (dto.CreateCoreValueResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, userId, coreValue)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateCoreValue")</span>
        }

        <span class="cov8" title="1">var r0 dto.CreateCoreValueResp
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int64, dto.CreateCoreValueReq) (dto.CreateCoreValueResp, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userId, coreValue)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int64, dto.CreateCoreValueReq) dto.CreateCoreValueResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userId, coreValue)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.CreateCoreValueResp)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int64, dto.CreateCoreValueReq) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userId, coreValue)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetCoreValue provides a mock function with given fields: ctx, coreValueID
func (_m *CoreValueStorer) GetCoreValue(ctx context.Context, coreValueID int64) (dto.GetCoreValueResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, coreValueID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetCoreValue")</span>
        }

        <span class="cov8" title="1">var r0 dto.GetCoreValueResp
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int64) (dto.GetCoreValueResp, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, coreValueID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int64) dto.GetCoreValueResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, coreValueID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.GetCoreValueResp)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, coreValueID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// ListCoreValues provides a mock function with given fields: ctx
func (_m *CoreValueStorer) ListCoreValues(ctx context.Context) ([]dto.ListCoreValuesResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ListCoreValues")</span>
        }

        <span class="cov8" title="1">var r0 []dto.ListCoreValuesResp
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) ([]dto.ListCoreValuesResp, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context) []dto.ListCoreValuesResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]dto.ListCoreValuesResp)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UpdateCoreValue provides a mock function with given fields: ctx, coreValueID, coreValue
func (_m *CoreValueStorer) UpdateCoreValue(ctx context.Context, coreValueID int64, coreValue dto.UpdateQueryRequest) (dto.UpdateCoreValuesResp, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, coreValueID, coreValue)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateCoreValue")</span>
        }

        <span class="cov8" title="1">var r0 dto.UpdateCoreValuesResp
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int64, dto.UpdateQueryRequest) (dto.UpdateCoreValuesResp, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, coreValueID, coreValue)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int64, dto.UpdateQueryRequest) dto.UpdateCoreValuesResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, coreValueID, coreValue)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(dto.UpdateCoreValuesResp)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int64, dto.UpdateQueryRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, coreValueID, coreValue)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewCoreValueStorer creates a new instance of CoreValueStorer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCoreValueStorer(t interface {
        mock.TestingT
        Cleanup(func())
}) *CoreValueStorer <span class="cov8" title="1">{
        mock := &amp;CoreValueStorer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        repository "github.com/joshsoftware/peerly-backend/internal/repository"
        mock "github.com/stretchr/testify/mock"

        sqlx "github.com/jmoiron/sqlx"
)

// RepositoryTransaction is an autogenerated mock type for the RepositoryTransaction type
type RepositoryTransaction struct {
        mock.Mock
}

// BeginTx provides a mock function with given fields: ctx
func (_m *RepositoryTransaction) BeginTx(ctx context.Context) (repository.Transaction, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BeginTx")</span>
        }

        <span class="cov0" title="0">var r0 repository.Transaction
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (repository.Transaction, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) repository.Transaction); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(repository.Transaction)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// HandleTransaction provides a mock function with given fields: ctx, tx, isSuccess
func (_m *RepositoryTransaction) HandleTransaction(ctx context.Context, tx repository.Transaction, isSuccess bool) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, tx, isSuccess)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for HandleTransaction")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, bool) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, isSuccess)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// InitiateQueryExecutor provides a mock function with given fields: tx
func (_m *RepositoryTransaction) InitiateQueryExecutor(tx repository.Transaction) sqlx.Ext <span class="cov0" title="0">{
        ret := _m.Called(tx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InitiateQueryExecutor")</span>
        }

        <span class="cov0" title="0">var r0 sqlx.Ext
        if rf, ok := ret.Get(0).(func(repository.Transaction) sqlx.Ext); ok </span><span class="cov0" title="0">{
                r0 = rf(tx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sqlx.Ext)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// NewRepositoryTransaction creates a new instance of RepositoryTransaction. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepositoryTransaction(t interface {
        mock.TestingT
        Cleanup(func())
}) *RepositoryTransaction <span class="cov0" title="0">{
        mock := &amp;RepositoryTransaction{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        dto "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        mock "github.com/stretchr/testify/mock"

        repository "github.com/joshsoftware/peerly-backend/internal/repository"

        sqlx "github.com/jmoiron/sqlx"
)

// RewardStorer is an autogenerated mock type for the RewardStorer type
type RewardStorer struct {
        mock.Mock
}

// BeginTx provides a mock function with given fields: ctx
func (_m *RewardStorer) BeginTx(ctx context.Context) (repository.Transaction, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BeginTx")</span>
        }

        <span class="cov8" title="1">var r0 repository.Transaction
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (repository.Transaction, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context) repository.Transaction); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(repository.Transaction)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// DeduceRewardQuotaOfUser provides a mock function with given fields: ctx, tx, userId, points
func (_m *RewardStorer) DeduceRewardQuotaOfUser(ctx context.Context, tx repository.Transaction, userId int64, points int) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, userId, points)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeduceRewardQuotaOfUser")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int64, int) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, userId, points)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int64, int) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, userId, points)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, int64, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, userId, points)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GiveReward provides a mock function with given fields: ctx, tx, reward
func (_m *RewardStorer) GiveReward(ctx context.Context, tx repository.Transaction, reward dto.Reward) (repository.Reward, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, reward)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GiveReward")</span>
        }

        <span class="cov8" title="1">var r0 repository.Reward
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, dto.Reward) (repository.Reward, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, reward)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, dto.Reward) repository.Reward); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, reward)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(repository.Reward)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, dto.Reward) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, reward)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// HandleTransaction provides a mock function with given fields: ctx, tx, isSuccess
func (_m *RewardStorer) HandleTransaction(ctx context.Context, tx repository.Transaction, isSuccess bool) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, tx, isSuccess)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for HandleTransaction")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, bool) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, isSuccess)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// InitiateQueryExecutor provides a mock function with given fields: tx
func (_m *RewardStorer) InitiateQueryExecutor(tx repository.Transaction) sqlx.Ext <span class="cov0" title="0">{
        ret := _m.Called(tx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InitiateQueryExecutor")</span>
        }

        <span class="cov0" title="0">var r0 sqlx.Ext
        if rf, ok := ret.Get(0).(func(repository.Transaction) sqlx.Ext); ok </span><span class="cov0" title="0">{
                r0 = rf(tx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sqlx.Ext)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// IsUserRewardForAppreciationPresent provides a mock function with given fields: ctx, tx, apprId, senderId
func (_m *RewardStorer) IsUserRewardForAppreciationPresent(ctx context.Context, tx repository.Transaction, apprId int64, senderId int64) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, apprId, senderId)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for IsUserRewardForAppreciationPresent")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int64, int64) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, apprId, senderId)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int64, int64) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, apprId, senderId)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, int64, int64) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, apprId, senderId)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UserHasRewardQuota provides a mock function with given fields: ctx, tx, userID, points
func (_m *RewardStorer) UserHasRewardQuota(ctx context.Context, tx repository.Transaction, userID int64, points int64) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, userID, points)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UserHasRewardQuota")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int64, int64) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, userID, points)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, repository.Transaction, int64, int64) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, userID, points)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, repository.Transaction, int64, int64) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, userID, points)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewRewardStorer creates a new instance of RewardStorer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRewardStorer(t interface {
        mock.TestingT
        Cleanup(func())
}) *RewardStorer <span class="cov0" title="0">{
        mock := &amp;RewardStorer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// Transaction is an autogenerated mock type for the Transaction type
type Transaction struct {
        mock.Mock
}

// Commit provides a mock function with given fields:
func (_m *Transaction) Commit() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Commit")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Rollback provides a mock function with given fields:
func (_m *Transaction) Rollback() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Rollback")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewTransaction creates a new instance of Transaction. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransaction(t interface {
        mock.TestingT
        Cleanup(func())
}) *Transaction <span class="cov0" title="0">{
        mock := &amp;Transaction{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        dto "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        mock "github.com/stretchr/testify/mock"

        repository "github.com/joshsoftware/peerly-backend/internal/repository"
)

// UserStorer is an autogenerated mock type for the UserStorer type
type UserStorer struct {
        mock.Mock
}

// CreateNewUser provides a mock function with given fields: ctx, u
func (_m *UserStorer) CreateNewUser(ctx context.Context, u dto.RegisterUser) (dto.GetUserResp, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, u)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateNewUser")</span>
        }

        <span class="cov0" title="0">var r0 dto.GetUserResp
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, dto.RegisterUser) (dto.GetUserResp, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, u)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, dto.RegisterUser) dto.GetUserResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, u)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(dto.GetUserResp)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, dto.RegisterUser) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, u)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetGradeByName provides a mock function with given fields: ctx, name
func (_m *UserStorer) GetGradeByName(ctx context.Context, name string) (repository.Grade, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetGradeByName")</span>
        }

        <span class="cov0" title="0">var r0 repository.Grade
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (repository.Grade, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) repository.Grade); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(repository.Grade)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetRewardMultiplier provides a mock function with given fields: ctx
func (_m *UserStorer) GetRewardMultiplier(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetRewardMultiplier")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetRoleByName provides a mock function with given fields: ctx, name
func (_m *UserStorer) GetRoleByName(ctx context.Context, name string) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetRoleByName")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetUserByEmail provides a mock function with given fields: ctx, email
func (_m *UserStorer) GetUserByEmail(ctx context.Context, email string) (dto.GetUserResp, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByEmail")</span>
        }

        <span class="cov0" title="0">var r0 dto.GetUserResp
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (dto.GetUserResp, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) dto.GetUserResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(dto.GetUserResp)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetUserList provides a mock function with given fields: ctx, reqData
func (_m *UserStorer) GetUserList(ctx context.Context, reqData dto.UserListReq) ([]dto.GetUserListResp, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, reqData)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserList")</span>
        }

        <span class="cov0" title="0">var r0 []dto.GetUserListResp
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, dto.UserListReq) ([]dto.GetUserListResp, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, reqData)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, dto.UserListReq) []dto.GetUserListResp); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, reqData)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]dto.GetUserListResp)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, dto.UserListReq) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, reqData)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SyncData provides a mock function with given fields: ctx, updateData
func (_m *UserStorer) SyncData(ctx context.Context, updateData dto.UpdateUserData) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, updateData)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SyncData")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, dto.UpdateUserData) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, updateData)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewUserStorer creates a new instance of UserStorer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserStorer(t interface {
        mock.TestingT
        Cleanup(func())
}) *UserStorer <span class="cov0" title="0">{
        mock := &amp;UserStorer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/jmoiron/sqlx"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        logger "github.com/sirupsen/logrus"
)

type appreciationsStore struct {
        BaseRepository
}

func NewAppreciationRepo(db *sqlx.DB) repository.AppreciationStorer <span class="cov0" title="0">{
        return &amp;appreciationsStore{
                BaseRepository: BaseRepository{db},
        }
}</span>

func (appr *appreciationsStore) CreateAppreciation(ctx context.Context, tx repository.Transaction, appreciation dto.Appreciation) (repository.Appreciation, error) <span class="cov0" title="0">{

        insertQuery, args, err := sq.
                Insert("appreciations").Columns(constants.CreateAppreciationColumns...).
                Values(appreciation.CoreValueID, appreciation.Description, appreciation.Quarter, appreciation.Sender, appreciation.Receiver).
                PlaceholderFormat(sq.Dollar).
                Suffix("RETURNING \"id\",\"core_value_id\", \"description\",\"total_reward_points\",\"quarter\",\"sender\",\"receiver\",\"created_at\",\"updated_at\"").
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return repository.Appreciation{}, apperrors.InternalServer
        }</span>
        <span class="cov0" title="0">queryExecutor := appr.InitiateQueryExecutor(tx)
        var resAppr repository.Appreciation
        err = queryExecutor.QueryRowx(insertQuery, args...).Scan(&amp;resAppr.ID, &amp;resAppr.CoreValueID, &amp;resAppr.Description, &amp;resAppr.TotalRewards, &amp;resAppr.Quarter, &amp;resAppr.Sender, &amp;resAppr.Receiver, &amp;resAppr.CreatedAt, &amp;resAppr.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error executing create certificate insert query: ", err)
                return repository.Appreciation{}, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">return resAppr, nil</span>
}

func (appr *appreciationsStore) GetAppreciationById(ctx context.Context, tx repository.Transaction, apprId int) (repository.AppreciationInfo, error) <span class="cov0" title="0">{

        // Build the SQL query
        query, args, err := sq.Select(
                "a.id",
                "cv.name AS core_value_name",
                "a.description",
                "a.is_valid",
                "a.total_reward_points",
                "a.quarter",
                "u_sender.id AS sender_id",
                "u_sender.first_name AS sender_first_name",
                "u_sender.last_name AS sender_last_name",
                "u_sender.profile_image_url AS sender_image_url",
                "u_sender.designation AS sender_designation",
                "u_receiver.id AS receiver_id",
                "u_receiver.first_name AS receiver_first_name",
                "u_receiver.last_name AS receiver_last_name",
                "u_receiver.profile_image_url AS receiver_image_url",
                "u_receiver.designation AS receiver_designation",
                "a.created_at",
                "a.updated_at",
        ).From("appreciations a").
                LeftJoin("users u_sender ON a.sender = u_sender.id").
                LeftJoin("users u_receiver ON a.receiver = u_receiver.id").
                LeftJoin("core_values cv ON a.core_value_id = cv.id").
                PlaceholderFormat(sq.Dollar).
                Where(sq.And{
                        sq.Eq{"a.id": apprId},
                        sq.Eq{"is_valid": true},
                }).
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err ", err.Error())
                return repository.AppreciationInfo{}, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">queryExecutor := appr.InitiateQueryExecutor(tx)

        var resAppr repository.AppreciationInfo

        // Execute the query
        err = queryExecutor.QueryRowx(query, args...).Scan(
                &amp;resAppr.ID,
                &amp;resAppr.CoreValueName,
                &amp;resAppr.Description,
                &amp;resAppr.IsValid,
                &amp;resAppr.TotalRewards,
                &amp;resAppr.Quarter,
                &amp;resAppr.SenderId,
                &amp;resAppr.SenderFirstName,
                &amp;resAppr.SenderLastName,
                &amp;resAppr.SenderImageURL,
                &amp;resAppr.SenderDesignation,
                &amp;resAppr.ReceiverId,
                &amp;resAppr.ReceiverFirstName,
                &amp;resAppr.ReceiverLastName,
                &amp;resAppr.ReceiverImageURL,
                &amp;resAppr.ReceiverDesignation,
                &amp;resAppr.CreatedAt,
                &amp;resAppr.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        logger.Warn("no appreciation found with id: ", apprId)
                        return repository.AppreciationInfo{}, apperrors.AppreciationNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to execute query: ", err.Error())
                return repository.AppreciationInfo{}, apperrors.InternalServer</span>
        }
        <span class="cov0" title="0">return resAppr, nil</span>
}

func (appr *appreciationsStore) GetAppreciation(ctx context.Context, tx repository.Transaction, filter dto.AppreciationFilter) ([]repository.AppreciationInfo, repository.Pagination, error) <span class="cov0" title="0">{

        // query builder for counting total records
        countQueryBuilder := sq.Select("COUNT(*)").
                From("appreciations a").
                LeftJoin("users u_sender ON a.sender = u_sender.id").
                LeftJoin("users u_receiver ON a.receiver = u_receiver.id").
                LeftJoin("core_values cv ON a.core_value_id = cv.id").
                PlaceholderFormat(sq.Dollar).
                Where(sq.Eq{"a.is_valid": true})

        if filter.Name != "" </span><span class="cov0" title="0">{
                countQueryBuilder = countQueryBuilder.Where(
                        "(CONCAT(u_sender.first_name, ' ', u_sender.last_name) LIKE ? OR "+
                                "CONCAT(u_receiver.first_name, ' ', u_receiver.last_name) LIKE ?)",
                        fmt.Sprintf("%%%s%%", filter.Name), fmt.Sprintf("%%%s%%", filter.Name),
                )
        }</span>

        <span class="cov0" title="0">countSql, countArgs, err := countQueryBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build count query: ", err.Error())
                return []repository.AppreciationInfo{}, repository.Pagination{}, apperrors.InternalServerError
        }</span>

        <span class="cov0" title="0">queryExecutor := appr.InitiateQueryExecutor(tx)
        var totalRecords int64
        err = queryExecutor.QueryRowx(countSql, countArgs...).Scan(&amp;totalRecords)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to execute count query: ", err.Error())
                return []repository.AppreciationInfo{}, repository.Pagination{}, apperrors.InternalServerError
        }</span>

        <span class="cov0" title="0">pagination := GetPaginationMetaData(filter.Page, filter.Limit, totalRecords)
        fmt.Println("pagination: ", pagination)
        // Initialize the Squirrel query builder
        queryBuilder := sq.Select(
                "a.id",
                "cv.name AS core_value_name",
                "a.description",
                "a.is_valid",
                "a.total_reward_points",
                "a.quarter",
                "u_sender.first_name AS sender_first_name",
                "u_sender.last_name AS sender_last_name",
                "u_sender.profile_image_url AS sender_image_url",
                "u_sender.designation AS sender_designation",
                "u_receiver.first_name AS receiver_first_name",
                "u_receiver.last_name AS receiver_last_name",
                "u_receiver.profile_image_url AS receiver_image_url",
                "u_receiver.designation AS receiver_designation",
                "a.created_at",
                "a.updated_at",
        ).From("appreciations a").
                LeftJoin("users u_sender ON a.sender = u_sender.id").
                LeftJoin("users u_receiver ON a.receiver = u_receiver.id").
                LeftJoin("core_values cv ON a.core_value_id = cv.id").
                PlaceholderFormat(sq.Dollar).
                Where(sq.Eq{"a.is_valid": true})

        if filter.Name != "" </span><span class="cov0" title="0">{
                queryBuilder = queryBuilder.Where(
                        "(CONCAT(u_sender.first_name, ' ', u_sender.last_name) LIKE ? OR "+
                                "CONCAT(u_receiver.first_name, ' ', u_receiver.last_name) LIKE ?)",
                        fmt.Sprintf("%%%s%%", filter.Name), fmt.Sprintf("%%%s%%", filter.Name),
                )
        }</span>

        <span class="cov0" title="0">if filter.SortOrder != "" </span><span class="cov0" title="0">{
                queryBuilder = queryBuilder.OrderBy(fmt.Sprintf("a.created_at %s", filter.SortOrder))
        }</span>

        <span class="cov0" title="0">offset := (filter.Page - 1) * filter.Limit

        // Add pagination
        queryBuilder = queryBuilder.Limit(uint64(filter.Limit)).Offset(uint64(offset))
        sql, args, err := queryBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build query: ", err.Error())
                return nil, repository.Pagination{}, apperrors.InternalServerError
        }</span>

        <span class="cov0" title="0">queryExecutor = appr.InitiateQueryExecutor(tx)
        res := make([]repository.AppreciationInfo, 0)
        err = sqlx.Select(queryExecutor, &amp;res, sql, args...)
        // rows, err := queryExecutor.Query(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to execute query: ", err.Error())
                return nil, repository.Pagination{}, apperrors.InternalServerError
        }</span>
        // defer rows.Close()

        // for rows.Next() {
        //         fmt.Println("Hello")
        //         var resAppr repository.AppreciationInfo
        //         err = rows.Scan(
        //                 &amp;resAppr.ID,
        //                 &amp;resAppr.CoreValueName,
        //                 &amp;resAppr.Description,
        //                 &amp;resAppr.IsValid,
        //                 &amp;resAppr.TotalRewards,
        //                 &amp;resAppr.Quarter,
        //                 &amp;resAppr.SenderFirstName,
        //                 &amp;resAppr.SenderLastName,
        //                 &amp;resAppr.SenderImageURL,
        //                 &amp;resAppr.SenderDesignation,
        //                 &amp;resAppr.ReceiverFirstName,
        //                 &amp;resAppr.ReceiverLastName,
        //                 &amp;resAppr.ReceiverImageURL,
        //                 &amp;resAppr.ReceiverDesignation,
        //                 &amp;resAppr.CreatedAt,
        //                 &amp;resAppr.UpdatedAt,
        //         )
        //         if err != nil {
        //                 logger.Error("failed to scan row: ", err.Error())
        //                 return []repository.AppreciationInfo{}, repository.Pagination{}, apperrors.InternalServerError
        //         }
        //         res = append(res, resAppr)
        // }

        <span class="cov0" title="0">return res, pagination, nil</span>
}

func (appr *appreciationsStore) ValidateAppreciation(ctx context.Context, tx repository.Transaction, isValid bool, apprId int) (bool, error) <span class="cov0" title="0">{
        query, args, err := sq.Update("appreciations").
                Set("is_valid", isValid).
                Where(sq.And{
                        sq.Eq{"id": apprId},
                        sq.Eq{"is_valid": true},
                }).
                PlaceholderFormat(sq.Dollar).
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error building SQL: ", err.Error())
                return false, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">queryExecutor := appr.InitiateQueryExecutor(tx)

        result, err := queryExecutor.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error executing SQL: ", err.Error())
                return false, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error getting rows affected: ", err.Error())
                return false, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("No rows affected")
                return false, apperrors.AppreciationNotFound
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (appr *appreciationsStore) IsUserPresent(ctx context.Context, tx repository.Transaction, userID int64) (bool, error) <span class="cov0" title="0">{
        // Initialize the Squirrel query builder
        psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

        // Build the SQL query
        query, args, err := psql.Select("COUNT(*)").
                From("users").
                Where(sq.Eq{"id": userID}).
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err ", err.Error())
                return false, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">queryExecutor := appr.InitiateQueryExecutor(tx)

        var count int
        // Execute the query
        err = queryExecutor.QueryRowx(query, args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to execute query: ", err.Error())
                return false, apperrors.InternalServer
        }</span>

        // Check if user is present
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (appr *appreciationsStore) UpdateAppreciationTotalRewardsOfYesterday(ctx context.Context, tx repository.Transaction) (bool, error) <span class="cov0" title="0">{
        fmt.Println("UpdateAppreciationTotalRewardsOfYesterday")

        // Initialize query executor
        queryExecutor := appr.InitiateQueryExecutor(tx)

        // Build the SQL update query with subquery
        query := `
UPDATE appreciations AS app
SET total_reward_points = total_reward_points + agg.total_points
FROM (
    SELECT appreciation_id, SUM(r.point * g.points) AS total_points
    FROM rewards r
    JOIN appreciations a ON r.appreciation_id = a.id
    JOIN users u ON r.sender = u.id
    JOIN grades g ON u.grade_id = g.id
    WHERE a.is_valid = true
      AND r.created_at &gt;= EXTRACT(EPOCH FROM TIMESTAMP 'yesterday'::TIMESTAMP) * 1000
     AND r.created_at &gt;= EXTRACT(EPOCH FROM TIMESTAMP 'today'::TIMESTAMP) * 1000
    GROUP BY appreciation_id
) AS agg
WHERE app.id = agg.appreciation_id;
    `

        // Execute the query using the query executor
        _, err := queryExecutor.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error executing SQL query:", err.Error())
                return false, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (appr *appreciationsStore) UpdateUserBadgesBasedOnTotalRewards(ctx context.Context, tx repository.Transaction) (bool, error) <span class="cov0" title="0">{
        queryExecutor := appr.InitiateQueryExecutor(tx)
        // Example function to get the quarter start time (you should replace this with your logic)
        afterTime := GetQuarterStartUnixTime()

        // Construct the plain SQL query
        query := `
                -- Calculate total reward points for each receiver
WITH receiver_points AS (
    SELECT
        receiver,
        SUM(total_reward_points) AS total_points
    FROM
        appreciations
    WHERE
        Appreciations.is_valid = true AND appreciations.created_at &gt;=$1
    GROUP BY
        receiver
),

-- Determine eligible badges for each receiver
eligible_badges AS (
    SELECT
        rp.receiver AS user_id,
        b.id AS badge_id,
        ROW_NUMBER() OVER (PARTITION BY rp.receiver ORDER BY b.reward_points DESC) AS rn
    FROM
        receiver_points rp
    JOIN
        badges b ON rp.total_points &gt;= b.reward_points
),

-- Check for existing badges created within the last 7 days
existing_recent_badges AS (
    SELECT DISTINCT ON (ub.user_id, ub.badge_id)
        ub.user_id,
        ub.badge_id,
        ub.created_at
    FROM
        user_badges ub
    WHERE
        ub.created_at &gt;=$2
),

-- Filter eligible badges that are not conflicted within the last 7 days
eligible_non_conflicted_badges AS (
    SELECT
        eb.user_id,
        eb.badge_id,
        (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT AS created_at
    FROM
        eligible_badges eb
    LEFT JOIN
        existing_recent_badges erb ON eb.user_id = erb.user_id AND eb.badge_id = erb.badge_id
    WHERE
        erb.user_id IS NULL
)

-- Insert eligible non-conflicting badges into user_badges
INSERT INTO user_badges (badge_id, user_id, created_at)
SELECT
    badge_id,
    user_id,
    created_at
FROM
    eligible_non_conflicted_badges;
        `
        // Execute the query within the transaction context
        _, err := queryExecutor.Exec(query, afterTime, afterTime)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package repository

import (
        "context"
        "log"

        "github.com/jmoiron/sqlx"
        "github.com/joshsoftware/peerly-backend/internal/repository"
)

// BaseRepository holds Database instance
type BaseRepository struct {
        DB *sqlx.DB
}

// BaseTransaction holds transaction instance
type BaseTransaction struct {
        tx *sqlx.Tx
}

// BeginTx begins transaction and return transaction instance
func (repo *BaseRepository) BeginTx(ctx context.Context) (repository.Transaction, error) <span class="cov0" title="0">{

        txObj, err := repo.DB.BeginTxx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error occured while initiating database transaction: %v", err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;BaseTransaction{
                tx: txObj,
        }, nil</span>
}

// HandleTransaction commit transaction when transaction is successful else rollback
func (repo *BaseRepository) HandleTransaction(ctx context.Context, tx repository.Transaction, isSuccess bool) error <span class="cov0" title="0">{
        var err error
        if !isSuccess </span><span class="cov0" title="0">{
                err = tx.Rollback()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("error occurred while rollback database transaction: %v", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error occurred while commit database transaction: %v", err.Error())
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Commit method commit the transaction
func (repo *BaseTransaction) Commit() error <span class="cov0" title="0">{
        return repo.tx.Commit()
}</span>

// Rollback method Rollback the transaction
func (repo *BaseTransaction) Rollback() error <span class="cov0" title="0">{
        return repo.tx.Rollback()
}</span>

// InitiateQueryExecutor Populate the query executor so we can use a transaction if one is present.
// If we are not running inside a transaction then the plain sqlx.DB object is used.
func (repo *BaseRepository) InitiateQueryExecutor(tx repository.Transaction) (executor sqlx.Ext) <span class="cov0" title="0">{

        executor = repo.DB
        if tx != nil </span><span class="cov0" title="0">{
                txObj := tx.(*BaseTransaction)
                executor = txObj.tx
        }</span>

        <span class="cov0" title="0">return executor</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import (
        "context"

        "github.com/jmoiron/sqlx"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        logger "github.com/sirupsen/logrus"
)

type coreValueStore struct {
        DB *sqlx.DB
}

func NewCoreValueRepo(db *sqlx.DB) repository.CoreValueStorer <span class="cov0" title="0">{
        return &amp;coreValueStore{
                DB: db,
        }
}</span>

const (
        listCoreValuesQuery  = `SELECT id, name, description, parent_core_value_id FROM core_values`
        getCoreValueQuery    = `SELECT id, name, description, parent_core_value_id FROM core_values WHERE id = $1`
        createCoreValueQuery = `INSERT INTO core_values (name,
                description, parent_core_value_id) VALUES ($1, $2, $3) RETURNING id, name, description, parent_core_value_id`
        //edit dele
        deleteSubCoreValueQuery = `UPDATE core_values SET soft_delete = true, soft_delete_by = $1, updated_at = $2 WHERE org_id = $3 and parent_id = $4`
        deleteCoreValueQuery    = `UPDATE core_values SET soft_delete = true, soft_delete_by = $1, updated_at = $2 WHERE org_id = $3 and id = $4`
        //edit dele
        updateCoreValueQuery = `UPDATE core_values SET (name, description) =
                ($1, $2) where id = $3 RETURNING id, name, description, parent_core_value_id`

        // checkOrganisationQuery = `SELECT id from organizations WHERE id = $1`
        checkUniqueCoreVal = `SELECT id from core_values WHERE name = $1`
)

func (cs *coreValueStore) ListCoreValues(ctx context.Context) (coreValues []dto.ListCoreValuesResp, err error) <span class="cov0" title="0">{
        err = cs.DB.SelectContext(
                ctx,
                &amp;coreValues,
                listCoreValuesQuery,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(logger.Fields{
                        "err": err.Error(),
                }).Error("Error while getting core values")
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (cs *coreValueStore) GetCoreValue(ctx context.Context, coreValueID int64) (coreValue dto.GetCoreValueResp, err error) <span class="cov0" title="0">{
        err = cs.DB.GetContext(
                ctx,
                &amp;coreValue,
                getCoreValueQuery,
                coreValueID,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(logger.Fields{
                        "err":         err.Error(),
                        "coreValueId": coreValueID,
                }).Error("Error while getting core value")
                err = apperrors.InvalidCoreValueData
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (cs *coreValueStore) CreateCoreValue(ctx context.Context, userId int64, coreValue dto.CreateCoreValueReq) (resp dto.CreateCoreValueResp, err error) <span class="cov0" title="0">{

        err = cs.DB.GetContext(
                ctx,
                &amp;resp,
                createCoreValueQuery,
                coreValue.Name,
                coreValue.Description,
                coreValue.ParentCoreValueID,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(logger.Fields{
                        "err":               err.Error(),
                        "core_value_params": coreValue,
                }).Error("Error while creating core value")
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (cs *coreValueStore) UpdateCoreValue(ctx context.Context, coreValueID int64, updateReq dto.UpdateQueryRequest) (resp dto.UpdateCoreValuesResp, err error) <span class="cov0" title="0">{
        err = cs.DB.GetContext(
                ctx,
                &amp;resp,
                updateCoreValueQuery,
                updateReq.Name,
                updateReq.Description,
                coreValueID,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(logger.Fields{
                        "err":           err.Error(),
                        "core_value_id": coreValueID,
                }).Error("Error while updating core value")
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (cs *coreValueStore) CheckUniqueCoreVal(ctx context.Context, text string) (isUnique bool, err error) <span class="cov0" title="0">{
        isUnique = false
        resp := []int64{}
        err = cs.DB.SelectContext(
                ctx,
                &amp;resp,
                checkUniqueCoreVal,
                text,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(logger.Fields{
                        "err": err.Error(),
                }).Error("Error while checking unique core values")
                err = apperrors.InternalServerError
                return
        }</span>

        <span class="cov0" title="0">if len(resp) &lt;= 0 </span><span class="cov0" title="0">{
                isUnique = true
                return
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package repository

import (
        "time"

        "github.com/joshsoftware/peerly-backend/internal/repository"
)

func GetPaginationMetaData(page int64, limit int64, totalRecords int64) repository.Pagination <span class="cov0" title="0">{
        // Calculate pagination details

        var totalPages int64
        if limit == 0 </span><span class="cov0" title="0">{
                totalPages = 1
        }</span> else<span class="cov0" title="0"> {
                totalPages = (totalRecords / limit) + ((totalRecords % limit) &amp; 1)
        }</span>

        <span class="cov0" title="0">var pagination repository.Pagination

        // Handle next and pre
        // next
        if page &lt; totalPages </span><span class="cov0" title="0">{
                next := int64(page + 1)
                pagination.Next = &amp;next
        }</span>

        // pre
        <span class="cov0" title="0">if page &gt; 1 </span><span class="cov0" title="0">{
                previous := min(int64(page-1), int64(totalPages))
                pagination.Previous = &amp;previous
        }</span>

        <span class="cov0" title="0">pagination.TotalPage = totalPages
        pagination.CurrentPage = page
        pagination.RecordPerPage = limit
        pagination.TotalRecords = totalRecords
        return pagination</span>

}

// func GetQuarterStartUnixTime() int64 {
//     month := int(time.Now().Month())
//     quarterStartMonth := ((month - 1) / 3) * 3 + 1
//     return time.Date(time.Now().Year(), time.Month(quarterStartMonth), 1, 0, 0, 0, 0, time.Local).UnixMilli()
// }

func GetQuarterStartUnixTime() int64 <span class="cov0" title="0">{
        // Example function to get the Unix timestamp of the start of the quarter
        now := time.Now()
        quarterStart := time.Date(now.Year(), (now.Month()-1)/3*3+1, 1, 0, 0, 0, 0, time.UTC)
        return quarterStart.Unix() * 1000 // convert to milliseconds
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "context"
        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/jmoiron/sqlx"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/constants"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        logger "github.com/sirupsen/logrus"
)

type rewardStore struct {
        BaseRepository
}

func NewRewardRepo(db *sqlx.DB) repository.RewardStorer <span class="cov0" title="0">{
        return &amp;rewardStore{
                BaseRepository: BaseRepository{db},
        }
}</span>

func (rwrd *rewardStore) GiveReward(ctx context.Context, tx repository.Transaction, reward dto.Reward) (repository.Reward, error) <span class="cov0" title="0">{

        queryExecutor := rwrd.InitiateQueryExecutor(tx)
        insertQuery, args, err := sq.
                Insert("rewards").
                Columns(constants.CreateRewardColumns...).
                Values(reward.AppreciationId, reward.Point, reward.SenderId).
                PlaceholderFormat(sq.Dollar).
                Suffix("RETURNING \"id\",\"appreciation_id\", \"point\",\"sender\",\"created_at\"").
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err: ", "error in creating query", err.Error())
                return repository.Reward{}, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">var rewardInfo repository.Reward
        err = queryExecutor.QueryRowx(insertQuery, args...).Scan(&amp;rewardInfo.Id, &amp;rewardInfo.AppreciationId, &amp;rewardInfo.Point, &amp;rewardInfo.SenderId, &amp;rewardInfo.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error executing create reward insert query: ", err)
                return repository.Reward{}, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">return rewardInfo, nil</span>

}

func (rwrd *rewardStore) IsUserRewardForAppreciationPresent(ctx context.Context, tx repository.Transaction, apprId int64, senderId int64) (bool, error) <span class="cov0" title="0">{
        // Initialize the Squirrel query builder
        psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

        fmt.Println("appr id: ", apprId)
        fmt.Println("sender: ", senderId)
        // Build the SQL query
        query, args, err := psql.Select("COUNT(*)").
    From("rewards").
    Where(sq.And{
        sq.Eq{"appreciation_id": apprId},
        sq.Eq{"sender": senderId},
    }).
    ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err ", err.Error())
                return false, apperrors.InternalServer
        }</span>

        <span class="cov0" title="0">fmt.Println("query: ", query)

        queryExecutor := rwrd.InitiateQueryExecutor(tx)

        var count int
        // Execute the query
        err = queryExecutor.QueryRowx(query, args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to execute query: ", err.Error())
                return false, apperrors.InternalServer
        }</span>
        <span class="cov0" title="0">fmt.Println("count: ", count)
        // Check if user and appreciation id is present
        return count &gt; 0, nil</span>
}

func (rwrd *rewardStore) DeduceRewardQuotaOfUser(ctx context.Context, tx repository.Transaction, userId int64, points int) (bool, error) <span class="cov0" title="0">{
        queryExecutor := rwrd.InitiateQueryExecutor(tx)
        // Build the SQL query to update the reward_quota_balance
        updateQuery, args, err := sq.
                Update("users").
                Set("reward_quota_balance", sq.Expr("reward_quota_balance - ? * (SELECT points FROM grades WHERE id = users.grade_id)", points)).
                Where(sq.Eq{"id": userId}).
                PlaceholderFormat(sq.Dollar).
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err: building SQL Query ", err.Error())
                return false, err
        }</span>

        // Execute the query within the transaction context
        <span class="cov0" title="0">result, err := queryExecutor.Exec(updateQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err: error executing SQL query:", err.Error())
                return false, err
        }</span>

        // Check how many rows were affected
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("err: error getting rows affected:", err)
                return false, err
        }</span>

        // Return true if at least one row was updated, false otherwise
        <span class="cov0" title="0">return rowsAffected &gt; 0, nil</span>
}

func (rwrd *rewardStore) UserHasRewardQuota(ctx context.Context, tx repository.Transaction, userID int64, points int64) (bool, error) <span class="cov0" title="0">{
        // Initialize the Squirrel query builder
        // psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

        // Build the SQL query
        query := `
                SELECT COUNT(*)
                FROM users u
                JOIN grades g ON u.grade_id = g.id
                WHERE u.id = $1
                AND u.reward_quota_balance &gt;= $2 * g.points
        `

        // Arguments for the query
        args := []interface{}{userID, points}

        fmt.Println("id: ", userID, "points: ", points)
        fmt.Println("query: ", query)

        queryExecutor := rwrd.InitiateQueryExecutor(tx)

        var count int
        // Execute the query
        err := queryExecutor.QueryRowx(query, args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to execute query: ", err.Error())
                return false, apperrors.InternalServer
        }</span>
        <span class="cov0" title="0">fmt.Println("count: ", count)
        // Check if user is present
        return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strconv"

        "github.com/jmoiron/sqlx"
        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/dto"
        "github.com/joshsoftware/peerly-backend/internal/repository"
        logger "github.com/sirupsen/logrus"
)

type userStore struct {
        DB *sqlx.DB
}

func NewUserRepo(db *sqlx.DB) repository.UserStorer <span class="cov0" title="0">{
        return &amp;userStore{
                DB: db,
        }
}</span>

const (
        getUserByEmailQuery = `SELECT users.id, users.employee_id, users.first_name, users.last_name, users.email, users.profile_image_url, users.role_id, users.reward_quota_balance, users.designation, users.grade_id, grades.name FROM users JOIN grades ON grades.id = users.grade_id WHERE users.email = $1;
`

        createUser = `INSERT INTO users ( email, employee_id, first_name, last_name, profile_image_url, role_id, reward_quota_balance, grade_id, designation
        ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9
        ) RETURNING id, employee_id, email, first_name, last_name, profile_image_url, role_id, reward_quota_balance, created_at, grade_id, designation`

        getRoleByNameQuery = `SELECT id FROM roles WHERE name=$1 LIMIT 1`

        getGradeId = `SELECT id, name, points FROM grades WHERE name = $1`

        getRewardMultiplier = "select reward_multiplier from organization_config where id = 1"

        updateUserQuery = `UPDATE users SET (first_name, last_name, profile_image_url, designation, grade_id) =
                ($1, $2, $3, $4, $5) where email = $6`
)

// GetUserByEmail - Given an email address, return that user.
func (us *userStore) GetUserByEmail(ctx context.Context, email string) (user dto.GetUserResp, err error) <span class="cov0" title="0">{
        err = us.DB.Get(&amp;user, getUserByEmailQuery, email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        err = apperrors.UserNotFound
                        return
                }</span>
                // Possible that there's no rows in the result set
                <span class="cov0" title="0">logger.WithField("err", err.Error()).Error("Error selecting user from database by email " + email)
                err = apperrors.InternalServerError
                return</span>
        }

        <span class="cov0" title="0">return</span>
}

func (us *userStore) GetRoleByName(ctx context.Context, name string) (roleId int, err error) <span class="cov0" title="0">{
        err = us.DB.Get(&amp;roleId, getRoleByNameQuery, name)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("Error selecting role from database in GetRoleByName for name ", name)
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

// CreateNewUser - creates a new user in the database
func (us *userStore) CreateNewUser(ctx context.Context, u dto.RegisterUser) (resp dto.GetUserResp, err error) <span class="cov0" title="0">{

        err = us.DB.GetContext(
                ctx,
                &amp;resp,
                createUser,
                u.User.Email,
                u.User.EmpolyeeDetail.EmployeeId,
                u.User.PublicProfile.FirstName,
                u.User.PublicProfile.LastName,
                u.User.PublicProfile.ProfileImgUrl,
                u.RoleId,
                u.RewardQuotaBalance,
                u.GradeId,
                u.User.EmpolyeeDetail.Designation.Name,
        )

        if err != nil </span><span class="cov0" title="0">{
                // FAIL: Could not run insert query
                logger.WithField("err", err.Error()).Error("Error inserting user into database: " + u.User.Email)

                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (us *userStore) GetGradeByName(ctx context.Context, name string) (grade repository.Grade, err error) <span class="cov0" title="0">{
        err = us.DB.Get(&amp;grade, getGradeId, name)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        err = apperrors.GradeNotFound
                        return
                }</span>
                <span class="cov0" title="0">logger.WithField("err", err.Error()).Error("Error in retriving grade id of the grade ", name)
                err = apperrors.InternalServerError
                return</span>
        }
        <span class="cov0" title="0">return</span>
}

func (us *userStore) GetRewardMultiplier(ctx context.Context) (value int, err error) <span class="cov0" title="0">{
        err = us.DB.Get(&amp;value, getRewardMultiplier)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        logger.WithField("err", err.Error()).Error("No fields in organization config")
                        return
                }</span>
                <span class="cov0" title="0">logger.WithField("err", err.Error()).Error("Error in retriving reward_multiplier from organization config")
                return</span>
        }
        <span class="cov0" title="0">return</span>
}

func (us *userStore) SyncData(ctx context.Context, updateData dto.UpdateUserData) (err error) <span class="cov0" title="0">{
        _, err = us.DB.ExecContext(
                ctx,
                updateUserQuery,
                updateData.FirstName,
                updateData.LastName,
                updateData.ProfileImgUrl,
                updateData.Designation,
                updateData.GradeId,
                updateData.Email,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("err", err.Error()).Error("Error in data update query")
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Data update successful")

        return</span>

}

func (us *userStore) GetUserList(ctx context.Context, reqData dto.UserListReq) (resp []dto.GetUserListResp, err error) <span class="cov0" title="0">{
        getUserListQuery := "Select users.employee_id, users.email, users.first_name, users.last_name, grades.name, users.designation, users.profile_image_url from users join grades on grades.id = users.grade_id "

        if len(reqData.Name) &gt;= 0 </span><span class="cov0" title="0">{
                getUserListQuery += "where"
        }</span>
        <span class="cov0" title="0">for i, name := range reqData.Name </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        str := fmt.Sprint(" lower(first_name) like '%" + name + "%' or lower(last_name) like '%" + name + "%'")
                        getUserListQuery += str
                }</span> else<span class="cov0" title="0"> {
                        str := fmt.Sprint(" or lower(first_name) like '%" + name + "%' or lower(last_name) like '%" + name + "%'")
                        getUserListQuery += str
                }</span>
        }

        <span class="cov0" title="0">str := fmt.Sprint(" limit " + strconv.Itoa(reqData.PerPage) + " offset " + strconv.Itoa(reqData.PerPage*(reqData.Page-1)+1))
        getUserListQuery += str

        err = us.DB.Select(&amp;resp, getUserListQuery)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        logger.WithField("err", err.Error()).Error("No fields returned")
                        err = nil
                        return
                }</span>
                <span class="cov0" title="0">logger.WithField("err", err.Error()).Error("Error in fetching users from database")
                err = apperrors.InternalServerError
                return</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package repository

import (
        "database/sql"

        "github.com/joshsoftware/peerly-backend/internal/pkg/apperrors"
        "github.com/joshsoftware/peerly-backend/internal/pkg/config"
        logger "github.com/sirupsen/logrus"
)

func SeedData() (err error) <span class="cov0" title="0">{
        uri := config.ReadEnvString("DB_URI")

        db, _ := sql.Open(dbDriver, uri)
        defer db.Close()

        seedQueries := []string{
                //roles
                `INSERT INTO roles (id, name) VALUES (1, 'Super Admin')`,
                `INSERT INTO roles (id, name) VALUES (2, 'Admin')`,
                `INSERT INTO roles (id, name) VALUES (3, 'User')`,

                //grades
                `INSERT INTO grades (id,name, points) VALUES (1, 'J1',1000)`,
                `INSERT INTO grades (id,name, points) VALUES (2,'J2',900)`,
                `INSERT INTO grades (id,name, points) VALUES (3,'J4',800)`,
                `INSERT INTO grades (id,name, points) VALUES (4,'J6',700)`,
                `INSERT INTO grades (id,name, points) VALUES (5,'J7',600)`,
                `INSERT INTO grades (id,name, points) VALUES (6,'J8',500)`,
                `INSERT INTO grades (id,name, points) VALUES (7,'J9',400)`,
                `INSERT INTO grades (id,name, points) VALUES (8,'J10',300)`,
                `INSERT INTO grades (id,name, points) VALUES (9,'J11',200)`,
                `INSERT INTO grades (id,name, points) VALUES (10,'J12',100)`,

                //corevalues
                `INSERT INTO core_values (id,name,description, parent_core_value_id) VALUES (1,'Leadership','leadership quality',null)`,
                `INSERT INTO core_values (id,name,description, parent_core_value_id) VALUES (2,'Technical Excellence','tech genius',null)`,

                //badges
                `INSERT INTO badges (id,name,reward_points) VALUES (1,'Bronze',1500)`,
                `INSERT INTO badges (id,name,reward_points) VALUES (2,'Silver',3000)`,
                `INSERT INTO badges (id,name,reward_points) VALUES (3,'Gold',5000)`,
                `INSERT INTO badges (id,name,reward_points) VALUES (4,'Platinum',7000)`,

                //users
                `INSERT INTO users (id,employee_id,first_name,last_name,email,designation,reward_quota_balance,role_id,grade_id)
                VALUES (1,'26','Sameer','Tilak','sameer.tilak@joshsoftware.com','Digital Head',900,1,2)`,
                //organization config
                `INSERT INTO organization_config (id,reward_multiplier,reward_quota_renewal_frequency,timezone,created_by) VALUES (1,10,1,'UTC',1)`,
        }

        for _, query := range seedQueries </span><span class="cov0" title="0">{
                _, err := db.Exec(query)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Err", "failed to execute seed query (%s): %v", query, err)
                        return apperrors.InternalServer
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Seed data loaded successfully.")
        return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
